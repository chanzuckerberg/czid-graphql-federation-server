// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CZ ID graphQL federation generated schema should generate a valid schema 1`] = `
"schema {
  query: Query
  mutation: Mutation
}

directive @example(value: ObjMap) repeatable on ENUM | FIELD_DEFINITION | INPUT_OBJECT | OBJECT | SCALAR

directive @globalOptions(endpoint: String, operationHeaders: ObjMap, queryParams: ObjMap, queryStringOptions: ObjMap, sourceName: String) on OBJECT

directive @httpOperation(httpMethod: HTTPMethod, isBinary: Boolean, operationSpecificHeaders: ObjMap, path: String, queryParamArgMap: ObjMap, queryStringOptionsByParam: ObjMap, requestBaseBody: ObjMap) on FIELD_DEFINITION

directive @oneOf on INPUT_OBJECT | INTERFACE | OBJECT

directive @resolveRoot on FIELD_DEFINITION

type Accession implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  accessionId: String!
  accessionName: String!
  collectionId: Int!
  consensusGenomes(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [ConsensusGenomeOrderByClause!] = []
    where: ConsensusGenomeWhereClause = null
  ): ConsensusGenomeConnection!
  consensusGenomesAggregate(where: ConsensusGenomeWhereClause = null): ConsensusGenomeAggregate
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  ownerUserId: Int!
  producingRunId: ID
  updatedAt: DateTime
  upstreamDatabase(orderBy: [UpstreamDatabaseOrderByClause!] = [], where: UpstreamDatabaseWhereClause = null): UpstreamDatabase
}

type AccessionAggregate {
  aggregate: [AccessionAggregateFunctions!]
}

type AccessionAggregateFunctions {
  avg: AccessionNumericalColumns
  count(columns: AccessionCountColumns = null, distinct: Boolean = false): Int
  groupBy: AccessionGroupByOptions
  max: AccessionMinMaxColumns
  min: AccessionMinMaxColumns
  stddev: AccessionNumericalColumns
  sum: AccessionNumericalColumns
  variance: AccessionNumericalColumns
}

"""A connection to a list of items."""
type AccessionConnection {
  """Contains the nodes in this connection"""
  edges: [AccessionEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum AccessionCountColumns {
  accessionId
  accessionName
  collectionId
  consensusGenomes
  createdAt
  deletedAt
  id
  ownerUserId
  producingRunId
  updatedAt
  upstreamDatabase
}

input AccessionCreateInput {
  accessionId: String!
  accessionName: String!
  collectionId: Int!
  deletedAt: DateTime = null
  producingRunId: ID = null
  upstreamDatabaseId: ID!
}

"""An edge in a connection."""
type AccessionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Accession!
}

type AccessionGroupByOptions {
  accessionId: String
  accessionName: String
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  id: UUID
  ownerUserId: Int
  producingRunId: UUID
  updatedAt: DateTime
  upstreamDatabase: UpstreamDatabaseGroupByOptions
}

type AccessionMinMaxColumns {
  accessionId: String
  accessionName: String
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  ownerUserId: Int
  updatedAt: DateTime
}

type AccessionNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input AccessionOrderByClause {
  accessionId: orderBy
  accessionName: orderBy
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  id: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  updatedAt: orderBy
  upstreamDatabase: UpstreamDatabaseOrderByClause
}

input AccessionUpdateInput {
  accessionName: String = null
  deletedAt: DateTime = null
}

input AccessionWhereClause {
  accessionId: StrComparators
  accessionName: StrComparators
  collectionId: IntComparators
  consensusGenomes: ConsensusGenomeWhereClause
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  updatedAt: DatetimeComparators
  upstreamDatabase: UpstreamDatabaseWhereClause
}

input AccessionWhereClauseMutations {
  id: UUIDComparators
}

type AlignmentConfig {
  createdAt: ISO8601DateTime!
  indexDirSuffix: String
  lineageVersion: String!
  lineageVersionOld: Int
  name: String
  s3Accession2taxidPath: String
  s3DeuterostomeDbPath: String
  s3LineagePath: String
  s3NrDbPath: String
  s3NrLocDbPath: String
  s3NtDbPath: String
  s3NtInfoDbPath: String
  s3NtLocDbPath: String
  s3TaxonBlacklistPath: String
  updatedAt: ISO8601DateTime!
}

type AmrDeprecatedResults {
  allele: String
  annotation_gene: String
  coverage: Float
  created_at: String
  depth: Float
  dpm: Float
  drug_family: String
  genbank_accession: String
  gene: String
  id: Int
  pipeline_run_id: Int
  rpm: Float
  total_reads: Int
  updated_at: String
}

type AmrWorkflowResults {
  amr_hit: [query_AmrWorkflowResults_amr_hit_items]
  metric_amr: query_AmrWorkflowResults_metric_amr
}

input Annotation {
  name: String!
}

type AppConfig {
  key: String!
  value: String!
}

type Background {
  other_backgrounds: [query_Background_other_backgrounds_items]
  owned_backgrounds: [JSON]
}

"""
Represents non-fractional signed whole numeric values. Since the value may
exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar BigInt

input BoolComparators {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

type BulkDownload implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  downloadType: BulkDownloadType!
  file(where: FileWhereClause = null): File
  fileId: ID
  id: ID!
  ownerUserId: Int!
  producingRunId: ID
  updatedAt: DateTime
}

type BulkDownloadAggregate {
  aggregate: [BulkDownloadAggregateFunctions!]
}

type BulkDownloadAggregateFunctions {
  avg: BulkDownloadNumericalColumns
  count(columns: BulkDownloadCountColumns = null, distinct: Boolean = false): Int
  groupBy: BulkDownloadGroupByOptions
  max: BulkDownloadMinMaxColumns
  min: BulkDownloadMinMaxColumns
  stddev: BulkDownloadNumericalColumns
  sum: BulkDownloadNumericalColumns
  variance: BulkDownloadNumericalColumns
}

enum BulkDownloadCountColumns {
  collectionId
  createdAt
  deletedAt
  downloadType
  file
  id
  ownerUserId
  producingRunId
  updatedAt
}

input BulkDownloadCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  downloadType: BulkDownloadType!
  producingRunId: ID = null
}

type BulkDownloadGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  downloadType: BulkDownloadType
  id: UUID
  ownerUserId: Int
  producingRunId: UUID
  updatedAt: DateTime
}

type BulkDownloadMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  ownerUserId: Int
  updatedAt: DateTime
}

type BulkDownloadNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input BulkDownloadOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  downloadType: orderBy
  id: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  updatedAt: orderBy
}

enum BulkDownloadType {
  consensus_genome
  consensus_genome_intermediate_output_files
}

input BulkDownloadTypeEnumComparators {
  _eq: BulkDownloadType
  _gt: BulkDownloadType
  _gte: BulkDownloadType
  _in: [BulkDownloadType!]
  _is_null: Boolean
  _lt: BulkDownloadType
  _lte: BulkDownloadType
  _neq: BulkDownloadType
  _nin: [BulkDownloadType!]
}

input BulkDownloadUpdateInput {
  deletedAt: DateTime = null
}

input BulkDownloadWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  downloadType: BulkDownloadTypeEnumComparators
  id: UUIDComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  updatedAt: DatetimeComparators
}

input BulkDownloadWhereClauseMutations {
  id: UUIDComparators
}

type ConsensusGenome implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  accession(orderBy: [AccessionOrderByClause!] = [], where: AccessionWhereClause = null): Accession
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  intermediateOutputs(where: FileWhereClause = null): File
  intermediateOutputsId: ID
  metrics(orderBy: [MetricConsensusGenomeOrderByClause!] = [], where: MetricConsensusGenomeWhereClause = null): MetricConsensusGenome
  ownerUserId: Int!
  producingRunId: ID
  referenceGenome(orderBy: [ReferenceGenomeOrderByClause!] = [], where: ReferenceGenomeWhereClause = null): ReferenceGenome
  sequence(where: FileWhereClause = null): File
  sequenceId: ID
  sequencingRead(orderBy: [SequencingReadOrderByClause!] = [], where: SequencingReadWhereClause = null): SequencingRead
  taxon(orderBy: [TaxonOrderByClause!] = [], where: TaxonWhereClause = null): Taxon
  updatedAt: DateTime
}

type ConsensusGenomeAggregate {
  aggregate: [ConsensusGenomeAggregateFunctions!]
}

type ConsensusGenomeAggregateFunctions {
  avg: ConsensusGenomeNumericalColumns
  count(columns: ConsensusGenomeCountColumns = null, distinct: Boolean = false): Int
  groupBy: ConsensusGenomeGroupByOptions
  max: ConsensusGenomeMinMaxColumns
  min: ConsensusGenomeMinMaxColumns
  stddev: ConsensusGenomeNumericalColumns
  sum: ConsensusGenomeNumericalColumns
  variance: ConsensusGenomeNumericalColumns
}

"""A connection to a list of items."""
type ConsensusGenomeConnection {
  """Contains the nodes in this connection"""
  edges: [ConsensusGenomeEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum ConsensusGenomeCountColumns {
  accession
  collectionId
  createdAt
  deletedAt
  id
  intermediateOutputs
  metrics
  ownerUserId
  producingRunId
  referenceGenome
  sequence
  sequencingRead
  taxon
  updatedAt
}

input ConsensusGenomeCreateInput {
  accessionId: ID = null
  collectionId: Int!
  deletedAt: DateTime = null
  producingRunId: ID = null
  referenceGenomeId: ID = null
  sequencingReadId: ID!
  taxonId: ID = null
}

"""An edge in a connection."""
type ConsensusGenomeEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ConsensusGenome!
}

type ConsensusGenomeGroupByOptions {
  accession: AccessionGroupByOptions
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  id: UUID
  ownerUserId: Int
  producingRunId: UUID
  referenceGenome: ReferenceGenomeGroupByOptions
  sequencingRead: SequencingReadGroupByOptions
  taxon: TaxonGroupByOptions
  updatedAt: DateTime
}

type ConsensusGenomeMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  ownerUserId: Int
  updatedAt: DateTime
}

type ConsensusGenomeNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input ConsensusGenomeOrderByClause {
  accession: AccessionOrderByClause
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  id: orderBy
  metrics: MetricConsensusGenomeOrderByClause
  ownerUserId: orderBy
  producingRunId: orderBy
  referenceGenome: ReferenceGenomeOrderByClause
  sequencingRead: SequencingReadOrderByClause
  taxon: TaxonOrderByClause
  updatedAt: orderBy
}

type ConsensusGenomeOverviewRows {
  cgOverviewRows: [[String]]!
}

input ConsensusGenomeUpdateInput {
  deletedAt: DateTime = null
}

input ConsensusGenomeWhereClause {
  accession: AccessionWhereClause
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  metrics: MetricConsensusGenomeWhereClause
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  referenceGenome: ReferenceGenomeWhereClause
  sequencingRead: SequencingReadWhereClause
  taxon: TaxonWhereClause
  updatedAt: DatetimeComparators
}

input ConsensusGenomeWhereClauseMutations {
  id: UUIDComparators
}

type ConsensusGenomeWorkflowResults {
  metric_consensus_genome: query_ConsensusGenomeWorkflowResults_metric_consensus_genome
  reference_genome: query_ConsensusGenomeWorkflowResults_reference_genome
}

"""Autogenerated return type of CreateUser."""
type CreateUserPayload {
  archetypes: String
  email: String
  institution: String
  name: String
  role: Int
  segments: String
  sendActivation: Boolean
}

"""Date with time (isoformat)"""
scalar DateTime

input DatetimeComparators {
  _eq: DateTime
  _gt: DateTime
  _gte: DateTime
  _in: [DateTime!]
  _is_null: Boolean
  _lt: DateTime
  _lte: DateTime
  _neq: DateTime
  _nin: [DateTime!]
}

type DbSample {
  alignmentConfigName: String
  basespaceAccessToken: String
  clientUpdatedAt: ISO8601DateTime
  createdAt: ISO8601DateTime!
  dagVars: String
  doNotProcess: Boolean!
  hostGenomeId: Int
  hostGenomeName: String
  id: Int!
  initialWorkflow: String!
  inputFiles: [InputFile!]!
  maxInputFragments: Int
  name: String
  pipelineBranch: String
  pipelineCommit: String
  pipelineExecutionStrategy: String
  privateUntil: ISO8601DateTime
  projectId: Int
  s3Bowtie2IndexPath: String
  s3PreloadResultPath: String
  s3StarIndexPath: String
  sampleNotes: String
  status: String
  subsample: Int
  updatedAt: ISO8601DateTime!
  uploadError: String
  uploadedFromBasespace: Int!
  useTaxonWhitelist: Boolean!
  userId: Int!
  webCommit: String
}

type DeleteSamples {
  deleted_workflow_ids: [Int]
  error: String
}

type DerivedSampleOutput {
  hostGenomeName: String!
  pipelineRun: PipelineRun
  projectName: String!
  summaryStats: SampleSummaryStats
}

type Entity {
  collectionId: Int!
  id: ID!
  ownerUserId: Int!
  producingRunId: ID!
  type: String!
}

input EntityInputType {
  entityId: ID!
  entityType: String!
  name: String!
}

interface EntityInterface implements Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

input EntityWhereClause {
  collectionId: IntComparators
  entityId: UUIDComparators
  id: UUIDComparators
  ownerUserId: IntComparators
  producingRunId: IntComparators
}

type File {
  compressionType: Int
  contents: String
  createdAt: DateTime!
  downloadLink(expiration: Int! = 3600): SignedURL
  entity(where: EntityWhereClause = null): Entity
  entityFieldName: String!
  entityId: ID!
  fileFormat: String!
  id: ID!
  namespace: String!
  path: String!
  protocol: FileAccessProtocol!
  size: Int
  status: FileStatus!
  updatedAt: DateTime
  uploadError: String
}

enum FileAccessProtocol {
  https
  s3
}

input FileCreate {
  compressionType: String = null
  fileFormat: String!
  name: String!
  namespace: String!
  path: String!
  protocol: FileAccessProtocol!
}

enum FileStatus {
  FAILED
  PENDING
  SUCCESS
}

input FileStatusEnumComparators {
  _eq: FileStatus
  _gt: FileStatus
  _gte: FileStatus
  _in: [FileStatus!]
  _is_null: Boolean
  _lt: FileStatus
  _lte: FileStatus
  _neq: FileStatus
  _nin: [FileStatus!]
}

input FileUpload {
  compressionType: String = null
  fileFormat: String!
  name: String!
}

input FileWhereClause {
  compressionType: StrComparators
  entityFieldName: StrComparators
  entityId: UUIDComparators
  fileFormat: StrComparators
  id: UUIDComparators
  namespace: StrComparators
  path: StrComparators
  protocol: StrComparators
  size: IntComparators
  status: FileStatusEnumComparators
}

input FloatComparators {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

type GenomicRange implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  file(where: FileWhereClause = null): File
  fileId: ID
  id: ID!
  ownerUserId: Int!
  producingRunId: ID
  sequencingReads(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [SequencingReadOrderByClause!] = []
    where: SequencingReadWhereClause = null
  ): SequencingReadConnection!
  sequencingReadsAggregate(where: SequencingReadWhereClause = null): SequencingReadAggregate
  updatedAt: DateTime
}

type GenomicRangeAggregate {
  aggregate: [GenomicRangeAggregateFunctions!]
}

type GenomicRangeAggregateFunctions {
  avg: GenomicRangeNumericalColumns
  count(columns: GenomicRangeCountColumns = null, distinct: Boolean = false): Int
  groupBy: GenomicRangeGroupByOptions
  max: GenomicRangeMinMaxColumns
  min: GenomicRangeMinMaxColumns
  stddev: GenomicRangeNumericalColumns
  sum: GenomicRangeNumericalColumns
  variance: GenomicRangeNumericalColumns
}

enum GenomicRangeCountColumns {
  collectionId
  createdAt
  deletedAt
  file
  id
  ownerUserId
  producingRunId
  sequencingReads
  updatedAt
}

input GenomicRangeCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  producingRunId: ID = null
}

type GenomicRangeGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  id: UUID
  ownerUserId: Int
  producingRunId: UUID
  updatedAt: DateTime
}

type GenomicRangeMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  ownerUserId: Int
  updatedAt: DateTime
}

type GenomicRangeNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input GenomicRangeOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  id: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  updatedAt: orderBy
}

input GenomicRangeUpdateInput {
  deletedAt: DateTime = null
}

input GenomicRangeWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  sequencingReads: SequencingReadWhereClause
  updatedAt: DatetimeComparators
}

input GenomicRangeWhereClauseMutations {
  id: UUIDComparators
}

"""
The \`ID\` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as \`"4"\`) or integer (such as \`4\`) input value will be accepted as an ID.
"""
scalar GlobalID @specifiedBy(url: "https://relay.dev/graphql/objectidentification.htm")

type GraphQLFederationVersion {
  gitCommit: String
  version: String
}

enum HTTPMethod {
  CONNECT
  DELETE
  GET
  HEAD
  OPTIONS
  PATCH
  POST
  PUT
  TRACE
}

type HostGenome {
  createdAt: ISO8601DateTime!
  defaultBackgroundId: Int
  id: Int!
  name: String!
  s3Bowtie2IndexPath: String!
  s3Minimap2IndexPath: String
  s3StarIndexPath: String!
  samplesCount: Int!
  skipDeuteroFilter: Int!
  taxaCategory: String!
  updatedAt: ISO8601DateTime!
  user: User
  userId: Int
}

type HostOrganism implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  category: HostOrganismCategory!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  indexes(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [IndexFileOrderByClause!] = []
    where: IndexFileWhereClause = null
  ): IndexFileConnection!
  indexesAggregate(where: IndexFileWhereClause = null): IndexFileAggregate
  isDeuterostome: Boolean!
  name: String!
  ownerUserId: Int!
  producingRunId: ID
  railsHostGenomeId: Int
  samples(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [SampleOrderByClause!] = []
    where: SampleWhereClause = null
  ): SampleConnection!
  samplesAggregate(where: SampleWhereClause = null): SampleAggregate
  updatedAt: DateTime
  version: String!
}

type HostOrganismAggregate {
  aggregate: [HostOrganismAggregateFunctions!]
}

type HostOrganismAggregateFunctions {
  avg: HostOrganismNumericalColumns
  count(columns: HostOrganismCountColumns = null, distinct: Boolean = false): Int
  groupBy: HostOrganismGroupByOptions
  max: HostOrganismMinMaxColumns
  min: HostOrganismMinMaxColumns
  stddev: HostOrganismNumericalColumns
  sum: HostOrganismNumericalColumns
  variance: HostOrganismNumericalColumns
}

enum HostOrganismCategory {
  human
  insect
  non_human_animal
  unknown
}

input HostOrganismCategoryEnumComparators {
  _eq: HostOrganismCategory
  _gt: HostOrganismCategory
  _gte: HostOrganismCategory
  _in: [HostOrganismCategory!]
  _is_null: Boolean
  _lt: HostOrganismCategory
  _lte: HostOrganismCategory
  _neq: HostOrganismCategory
  _nin: [HostOrganismCategory!]
}

enum HostOrganismCountColumns {
  category
  collectionId
  createdAt
  deletedAt
  id
  indexes
  isDeuterostome
  name
  ownerUserId
  producingRunId
  railsHostGenomeId
  samples
  updatedAt
  version
}

input HostOrganismCreateInput {
  category: HostOrganismCategory!
  collectionId: Int!
  deletedAt: DateTime = null
  isDeuterostome: Boolean!
  name: String!
  producingRunId: ID = null
  railsHostGenomeId: Int = null
  version: String!
}

type HostOrganismGroupByOptions {
  category: HostOrganismCategory
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  id: UUID
  isDeuterostome: Boolean
  name: String
  ownerUserId: Int
  producingRunId: UUID
  railsHostGenomeId: Int
  updatedAt: DateTime
  version: String
}

type HostOrganismMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  name: String
  ownerUserId: Int
  railsHostGenomeId: Int
  updatedAt: DateTime
  version: String
}

type HostOrganismNumericalColumns {
  collectionId: Int
  ownerUserId: Int
  railsHostGenomeId: Int
}

input HostOrganismOrderByClause {
  category: orderBy
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  id: orderBy
  isDeuterostome: orderBy
  name: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  railsHostGenomeId: orderBy
  updatedAt: orderBy
  version: orderBy
}

input HostOrganismUpdateInput {
  category: HostOrganismCategory = null
  deletedAt: DateTime = null
  isDeuterostome: Boolean = null
  name: String = null
  version: String = null
}

input HostOrganismWhereClause {
  category: HostOrganismCategoryEnumComparators
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  indexes: IndexFileWhereClause
  isDeuterostome: BoolComparators
  name: StrComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  railsHostGenomeId: IntComparators
  samples: SampleWhereClause
  updatedAt: DatetimeComparators
  version: StrComparators
}

input HostOrganismWhereClauseMutations {
  id: UUIDComparators
}

"""An ISO 8601-encoded datetime"""
scalar ISO8601DateTime

type IndexFile implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  file(where: FileWhereClause = null): File
  fileId: ID
  hostOrganism(orderBy: [HostOrganismOrderByClause!] = [], where: HostOrganismWhereClause = null): HostOrganism
  id: ID!
  name: IndexTypes!
  ownerUserId: Int!
  producingRunId: ID
  updatedAt: DateTime
  upstreamDatabase(orderBy: [UpstreamDatabaseOrderByClause!] = [], where: UpstreamDatabaseWhereClause = null): UpstreamDatabase
  version: String!
}

type IndexFileAggregate {
  aggregate: [IndexFileAggregateFunctions!]
}

type IndexFileAggregateFunctions {
  avg: IndexFileNumericalColumns
  count(columns: IndexFileCountColumns = null, distinct: Boolean = false): Int
  groupBy: IndexFileGroupByOptions
  max: IndexFileMinMaxColumns
  min: IndexFileMinMaxColumns
  stddev: IndexFileNumericalColumns
  sum: IndexFileNumericalColumns
  variance: IndexFileNumericalColumns
}

"""A connection to a list of items."""
type IndexFileConnection {
  """Contains the nodes in this connection"""
  edges: [IndexFileEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum IndexFileCountColumns {
  collectionId
  createdAt
  deletedAt
  file
  hostOrganism
  id
  name
  ownerUserId
  producingRunId
  updatedAt
  upstreamDatabase
  version
}

input IndexFileCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  fileId: ID = null
  hostOrganismId: ID = null
  name: IndexTypes!
  producingRunId: ID = null
  upstreamDatabaseId: ID = null
  version: String!
}

"""An edge in a connection."""
type IndexFileEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: IndexFile!
}

type IndexFileGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  hostOrganism: HostOrganismGroupByOptions
  id: UUID
  name: IndexTypes
  ownerUserId: Int
  producingRunId: UUID
  updatedAt: DateTime
  upstreamDatabase: UpstreamDatabaseGroupByOptions
  version: String
}

type IndexFileMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  ownerUserId: Int
  updatedAt: DateTime
  version: String
}

type IndexFileNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input IndexFileOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  hostOrganism: HostOrganismOrderByClause
  id: orderBy
  name: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  updatedAt: orderBy
  upstreamDatabase: UpstreamDatabaseOrderByClause
  version: orderBy
}

input IndexFileUpdateInput {
  deletedAt: DateTime = null
  name: IndexTypes = null
  version: String = null
}

input IndexFileWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  hostOrganism: HostOrganismWhereClause
  id: UUIDComparators
  name: IndexTypesEnumComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  updatedAt: DatetimeComparators
  upstreamDatabase: UpstreamDatabaseWhereClause
  version: StrComparators
}

input IndexFileWhereClauseMutations {
  id: UUIDComparators
}

enum IndexTypes {
  accession2taxid
  bowtie2
  bowtie2_v2
  deuterostome
  diamond
  hisat2
  kallisto
  lineage
  minimap2_dna
  minimap2_long
  minimap2_rna
  minimap2_short
  nr
  nr_loc
  nt
  nt_info
  nt_loc
  original_transcripts_gtf
  star
  taxon_blacklist
}

input IndexTypesEnumComparators {
  _eq: IndexTypes
  _gt: IndexTypes
  _gte: IndexTypes
  _in: [IndexTypes!]
  _is_null: Boolean
  _lt: IndexTypes
  _lte: IndexTypes
  _neq: IndexTypes
  _nin: [IndexTypes!]
}

type InputFile {
  createdAt: ISO8601DateTime!
  id: Int!
  name: String
  parts: String
  presignedUrl: String
  sampleId: Int!
  source: String
  sourceType: String
  updatedAt: ISO8601DateTime
  uploadClient: String
}

input IntComparators {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input LimitOffsetClause {
  limit: Int
  offset: Int
}

type Metadatum implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  fieldName: String!
  id: ID!
  ownerUserId: Int!
  producingRunId: ID
  sample(orderBy: [SampleOrderByClause!] = [], where: SampleWhereClause = null): Sample
  updatedAt: DateTime
  value: String!
}

type MetadatumAggregate {
  aggregate: [MetadatumAggregateFunctions!]
}

type MetadatumAggregateFunctions {
  avg: MetadatumNumericalColumns
  count(columns: MetadatumCountColumns = null, distinct: Boolean = false): Int
  groupBy: MetadatumGroupByOptions
  max: MetadatumMinMaxColumns
  min: MetadatumMinMaxColumns
  stddev: MetadatumNumericalColumns
  sum: MetadatumNumericalColumns
  variance: MetadatumNumericalColumns
}

"""A connection to a list of items."""
type MetadatumConnection {
  """Contains the nodes in this connection"""
  edges: [MetadatumEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum MetadatumCountColumns {
  collectionId
  createdAt
  deletedAt
  fieldName
  id
  ownerUserId
  producingRunId
  sample
  updatedAt
  value
}

input MetadatumCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  fieldName: String!
  producingRunId: ID = null
  sampleId: ID!
  value: String!
}

"""An edge in a connection."""
type MetadatumEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Metadatum!
}

type MetadatumGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  fieldName: String
  id: UUID
  ownerUserId: Int
  producingRunId: UUID
  sample: SampleGroupByOptions
  updatedAt: DateTime
  value: String
}

type MetadatumMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  fieldName: String
  ownerUserId: Int
  updatedAt: DateTime
  value: String
}

type MetadatumNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input MetadatumOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  fieldName: orderBy
  id: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  sample: SampleOrderByClause
  updatedAt: orderBy
  value: orderBy
}

input MetadatumUpdateInput {
  deletedAt: DateTime = null
  value: String = null
}

input MetadatumWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  fieldName: StrComparators
  id: UUIDComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  sample: SampleWhereClause
  updatedAt: DatetimeComparators
  value: StrComparators
}

input MetadatumWhereClauseMutations {
  id: UUIDComparators
}

type MetricConsensusGenome implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  consensusGenome(orderBy: [ConsensusGenomeOrderByClause!] = [], where: ConsensusGenomeWhereClause = null): ConsensusGenome
  coverageBinSize: Float
  coverageBreadth: Float
  coverageDepth: Float
  coverageTotalLength: Int
  coverageViz: [[Float!]!]
  createdAt: DateTime!
  deletedAt: DateTime
  gcPercent: Float
  id: ID!
  mappedReads: Int
  nActg: Int
  nAmbiguous: Int
  nMissing: Int
  ownerUserId: Int!
  percentGenomeCalled: Float
  percentIdentity: Float
  producingRunId: ID
  refSnps: Int
  referenceGenomeLength: Float
  totalReads: Int
  updatedAt: DateTime
}

type MetricConsensusGenomeAggregate {
  aggregate: [MetricConsensusGenomeAggregateFunctions!]
}

type MetricConsensusGenomeAggregateFunctions {
  avg: MetricConsensusGenomeNumericalColumns
  count(columns: MetricConsensusGenomeCountColumns = null, distinct: Boolean = false): Int
  groupBy: MetricConsensusGenomeGroupByOptions
  max: MetricConsensusGenomeMinMaxColumns
  min: MetricConsensusGenomeMinMaxColumns
  stddev: MetricConsensusGenomeNumericalColumns
  sum: MetricConsensusGenomeNumericalColumns
  variance: MetricConsensusGenomeNumericalColumns
}

enum MetricConsensusGenomeCountColumns {
  collectionId
  consensusGenome
  coverageBinSize
  coverageBreadth
  coverageDepth
  coverageTotalLength
  coverageViz
  createdAt
  deletedAt
  gcPercent
  id
  mappedReads
  nActg
  nAmbiguous
  nMissing
  ownerUserId
  percentGenomeCalled
  percentIdentity
  producingRunId
  refSnps
  referenceGenomeLength
  totalReads
  updatedAt
}

input MetricConsensusGenomeCreateInput {
  collectionId: Int!
  consensusGenomeId: ID!
  coverageBinSize: Float = null
  coverageBreadth: Float = null
  coverageDepth: Float = null
  coverageTotalLength: Int = null
  coverageViz: [[Float!]!] = null
  deletedAt: DateTime = null
  gcPercent: Float = null
  mappedReads: Int = null
  nActg: Int = null
  nAmbiguous: Int = null
  nMissing: Int = null
  percentGenomeCalled: Float = null
  percentIdentity: Float = null
  producingRunId: ID = null
  refSnps: Int = null
  referenceGenomeLength: Float = null
  totalReads: Int = null
}

type MetricConsensusGenomeGroupByOptions {
  collectionId: Int
  consensusGenome: ConsensusGenomeGroupByOptions
  coverageBinSize: Float
  coverageBreadth: Float
  coverageDepth: Float
  coverageTotalLength: Int
  coverageViz: [[Float!]!]
  createdAt: DateTime
  deletedAt: DateTime
  gcPercent: Float
  id: UUID
  mappedReads: Int
  nActg: Int
  nAmbiguous: Int
  nMissing: Int
  ownerUserId: Int
  percentGenomeCalled: Float
  percentIdentity: Float
  producingRunId: UUID
  refSnps: Int
  referenceGenomeLength: Float
  totalReads: Int
  updatedAt: DateTime
}

type MetricConsensusGenomeMinMaxColumns {
  collectionId: Int
  coverageBinSize: Float
  coverageBreadth: Float
  coverageDepth: Float
  coverageTotalLength: Int
  createdAt: DateTime
  deletedAt: DateTime
  gcPercent: Float
  mappedReads: Int
  nActg: Int
  nAmbiguous: Int
  nMissing: Int
  ownerUserId: Int
  percentGenomeCalled: Float
  percentIdentity: Float
  refSnps: Int
  referenceGenomeLength: Float
  totalReads: Int
  updatedAt: DateTime
}

type MetricConsensusGenomeNumericalColumns {
  collectionId: Int
  coverageBinSize: Float
  coverageBreadth: Float
  coverageDepth: Float
  coverageTotalLength: Int
  gcPercent: Float
  mappedReads: Int
  nActg: Int
  nAmbiguous: Int
  nMissing: Int
  ownerUserId: Int
  percentGenomeCalled: Float
  percentIdentity: Float
  refSnps: Int
  referenceGenomeLength: Float
  totalReads: Int
}

input MetricConsensusGenomeOrderByClause {
  collectionId: orderBy
  consensusGenome: ConsensusGenomeOrderByClause
  coverageBinSize: orderBy
  coverageBreadth: orderBy
  coverageDepth: orderBy
  coverageTotalLength: orderBy
  coverageViz: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  gcPercent: orderBy
  id: orderBy
  mappedReads: orderBy
  nActg: orderBy
  nAmbiguous: orderBy
  nMissing: orderBy
  ownerUserId: orderBy
  percentGenomeCalled: orderBy
  percentIdentity: orderBy
  producingRunId: orderBy
  refSnps: orderBy
  referenceGenomeLength: orderBy
  totalReads: orderBy
  updatedAt: orderBy
}

input MetricConsensusGenomeUpdateInput {
  deletedAt: DateTime = null
}

input MetricConsensusGenomeWhereClause {
  collectionId: IntComparators
  consensusGenome: ConsensusGenomeWhereClause
  coverageBinSize: FloatComparators
  coverageBreadth: FloatComparators
  coverageDepth: FloatComparators
  coverageTotalLength: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  gcPercent: FloatComparators
  id: UUIDComparators
  mappedReads: IntComparators
  nActg: IntComparators
  nAmbiguous: IntComparators
  nMissing: IntComparators
  ownerUserId: IntComparators
  percentGenomeCalled: FloatComparators
  percentIdentity: FloatComparators
  producingRunId: UUIDComparators
  refSnps: IntComparators
  referenceGenomeLength: FloatComparators
  totalReads: IntComparators
  updatedAt: DatetimeComparators
}

input MetricConsensusGenomeWhereClauseMutations {
  id: UUIDComparators
}

type MngsRunInfo {
  createdAt: ISO8601DateTime
  finalized: Int
  reportReady: Boolean
  resultStatusDescription: String
  totalRuntime: Int
  withAssembly: Int
}

type MngsWorkflowResults {
  fed_lineage: [query_MngsWorkflowResults_fed_lineage_items]
  metric_mngs: query_MngsWorkflowResults_metric_mngs
  taxon_hit_results: query_MngsWorkflowResults_taxon_hit_results
}

type MultipartUploadCredentials {
  accessKeyId: String!
  expiration: String!
  namespace: String!
  path: String!
  protocol: String!
  secretAccessKey: String!
  sessionToken: String!
}

type MultipartUploadResponse {
  credentials: MultipartUploadCredentials!
  file: File!
}

type Mutation {
  CreateBulkDownload(input: mutationInput_CreateBulkDownload_input_Input): JSON @httpOperation(path: "/bulk_download", httpMethod: POST)
  DeleteSamples(input: mutationInput_DeleteSamples_input_Input): DeleteSamples @httpOperation(path: "/samples/bulk_delete", httpMethod: POST)
  KickoffAMRWorkflow(input: mutationInput_KickoffAMRWorkflow_input_Input, sampleId: String): [mutation_KickoffWGSWorkflow_items] @httpOperation(path: "/samples/{args.sampleId}/kickoff_workflow", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: POST)
  KickoffWGSWorkflow(input: mutationInput_KickoffWGSWorkflow_input_Input, sampleId: String): [mutation_KickoffWGSWorkflow_items] @httpOperation(path: "/samples/{args.sampleId}/kickoff_workflow", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: POST)
  UpdateMetadata(input: mutationInput_UpdateMetadata_input_Input, sampleId: String): UpdateMetadataReponse @httpOperation(path: "/samples/{args.sampleId}/save_metadata_v2", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: POST)
  UpdateSampleName(input: mutationInput_UpdateSampleNotes_input_Input, sampleId: String): UpdateSampleName @httpOperation(path: "/samples/{args.sampleId}/save_metadata", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: POST)
  UpdateSampleNotes(input: mutationInput_UpdateSampleNotes_input_Input, sampleId: String): UpdateSampleNotes @httpOperation(path: "/samples/{args.sampleId}/save_metadata", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: POST)
  concatenateFiles(ids: [UUID!]!): SignedURL!
  createAccession(input: AccessionCreateInput!): Accession!
  createBulkDownload(input: BulkDownloadCreateInput!): BulkDownload!
  createConsensusGenome(input: ConsensusGenomeCreateInput!): ConsensusGenome!
  createFile(entityFieldName: String!, entityId: ID!, file: FileCreate!): File!
  createGenomicRange(input: GenomicRangeCreateInput!): GenomicRange!
  createHostOrganism(input: HostOrganismCreateInput!): HostOrganism!
  createIndexFile(input: IndexFileCreateInput!): IndexFile!
  createMetadatum(input: MetadatumCreateInput!): Metadatum!
  createMetricConsensusGenome(input: MetricConsensusGenomeCreateInput!): MetricConsensusGenome!
  createReferenceGenome(input: ReferenceGenomeCreateInput!): ReferenceGenome!
  createSample(input: SampleCreateInput!): Sample!
  createSequencingRead(input: SequencingReadCreateInput!): SequencingRead!
  createTaxon(input: TaxonCreateInput!): Taxon!
  createUpstreamDatabase(input: UpstreamDatabaseCreateInput!): UpstreamDatabase!
  createUser(archetypes: String, email: String!, institution: String, name: String, role: Int, segments: String, sendActivation: Boolean): CreateUserPayload!
  createWorkflow(input: WorkflowCreateInput!): Workflow!
  createWorkflowRun(input: RunWorkflowVersionInput!): WorkflowRun!
  createWorkflowRunEntityInput(input: WorkflowRunEntityInputCreateInput!): WorkflowRunEntityInput!
  createWorkflowRunStep(input: WorkflowRunStepCreateInput!): WorkflowRunStep!
  createWorkflowVersion(input: WorkflowVersionCreateInput!): WorkflowVersion!
  deleteAccession(where: AccessionWhereClauseMutations!): [Accession!]!
  deleteBulkDownload(where: BulkDownloadWhereClauseMutations!): [BulkDownload!]!
  deleteConsensusGenome(where: ConsensusGenomeWhereClauseMutations!): [ConsensusGenome!]!
  deleteGenomicRange(where: GenomicRangeWhereClauseMutations!): [GenomicRange!]!
  deleteHostOrganism(where: HostOrganismWhereClauseMutations!): [HostOrganism!]!
  deleteIndexFile(where: IndexFileWhereClauseMutations!): [IndexFile!]!
  deleteMetadatum(where: MetadatumWhereClauseMutations!): [Metadatum!]!
  deleteMetricConsensusGenome(where: MetricConsensusGenomeWhereClauseMutations!): [MetricConsensusGenome!]!
  deleteOldBulkDownloads: [BulkDownload!]!
  deleteReferenceGenome(where: ReferenceGenomeWhereClauseMutations!): [ReferenceGenome!]!
  deleteSample(where: SampleWhereClauseMutations!): [Sample!]!
  deleteSequencingRead(where: SequencingReadWhereClauseMutations!): [SequencingRead!]!
  deleteTaxon(where: TaxonWhereClauseMutations!): [Taxon!]!
  deleteUpstreamDatabase(where: UpstreamDatabaseWhereClauseMutations!): [UpstreamDatabase!]!
  deleteWorkflow(where: WorkflowWhereClauseMutations!): [Workflow!]!
  deleteWorkflowRun(where: WorkflowRunWhereClauseMutations!): [WorkflowRun!]!
  deleteWorkflowRunEntityInput(where: WorkflowRunEntityInputWhereClauseMutations!): [WorkflowRunEntityInput!]!
  deleteWorkflowRunStep(where: WorkflowRunStepWhereClauseMutations!): [WorkflowRunStep!]!
  deleteWorkflowVersion(where: WorkflowVersionWhereClauseMutations!): [WorkflowVersion!]!
  markUploadComplete(fileId: ID!): File!
  runWorkflowRun(executionId: String = null, workflowRunId: ID!): WorkflowRun!
  runWorkflowVersion(executionId: String = null, input: RunWorkflowVersionInput!): WorkflowRun!
  updateAccession(input: AccessionUpdateInput!, where: AccessionWhereClauseMutations!): [Accession!]!
  updateBulkDownload(input: BulkDownloadUpdateInput!, where: BulkDownloadWhereClauseMutations!): [BulkDownload!]!
  updateConsensusGenome(input: ConsensusGenomeUpdateInput!, where: ConsensusGenomeWhereClauseMutations!): [ConsensusGenome!]!
  updateGenomicRange(input: GenomicRangeUpdateInput!, where: GenomicRangeWhereClauseMutations!): [GenomicRange!]!
  updateHostOrganism(input: HostOrganismUpdateInput!, where: HostOrganismWhereClauseMutations!): [HostOrganism!]!
  updateIndexFile(input: IndexFileUpdateInput!, where: IndexFileWhereClauseMutations!): [IndexFile!]!
  updateMetadatum(input: MetadatumUpdateInput!, where: MetadatumWhereClauseMutations!): [Metadatum!]!
  updateMetricConsensusGenome(input: MetricConsensusGenomeUpdateInput!, where: MetricConsensusGenomeWhereClauseMutations!): [MetricConsensusGenome!]!
  updateReferenceGenome(input: ReferenceGenomeUpdateInput!, where: ReferenceGenomeWhereClauseMutations!): [ReferenceGenome!]!
  updateSample(input: SampleUpdateInput!, where: SampleWhereClauseMutations!): [Sample!]!
  updateSequencingRead(input: SequencingReadUpdateInput!, where: SequencingReadWhereClauseMutations!): [SequencingRead!]!
  updateTaxon(input: TaxonUpdateInput!, where: TaxonWhereClauseMutations!): [Taxon!]!
  updateUpstreamDatabase(input: UpstreamDatabaseUpdateInput!, where: UpstreamDatabaseWhereClauseMutations!): [UpstreamDatabase!]!
  updateWorkflow(input: WorkflowUpdateInput!, where: WorkflowWhereClauseMutations!): [Workflow!]!
  updateWorkflowRun(input: WorkflowRunUpdateInput!, where: WorkflowRunWhereClauseMutations!): [WorkflowRun!]!
  updateWorkflowRunStep(input: WorkflowRunStepUpdateInput!, where: WorkflowRunStepWhereClauseMutations!): [WorkflowRunStep!]!
  uploadFile(entityFieldName: String!, entityId: ID!, expiration: Int! = 3600, file: FileUpload!): MultipartUploadResponse!
  uploadTemporaryFile(expiration: Int! = 3600): MultipartUploadResponse!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

scalar ObjMap

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Pathogen {
  category: String
  name: String
  taxId: Int
}

type PathogenList {
  citations: [String!]
  createdAt: ISO8601DateTime
  id: ID
  name: String
  pathogens: [Pathogen!]
  updatedAt: ISO8601DateTime
  version: String
}

type PersistedBackground {
  background_id: Int
}

type PipelineData {
  edges: [query_PipelineData_edges_items]
  stages: [query_PipelineData_stages_items]
  status: String
}

type PipelineRun {
  adjustedRemainingReads: Int
  alertSent: Boolean!
  alignmentConfig: AlignmentConfig
  alignmentConfigId: Int
  alignmentConfigName: String
  assembled: Int
  compressionRatio: Float
  createdAt: ISO8601DateTime
  dagVars: String
  deprecated: Boolean
  errorMessage: String
  executedAt: ISO8601DateTime
  finalized: Int
  fractionSubsampled: Float
  id: Int!
  jobStatus: String
  knownUserError: String
  maxInputFragments: Int
  pipelineBranch: String
  pipelineCommit: String
  pipelineExecutionStrategy: String
  pipelineVersion: String
  qcPercent: Float
  resultsFinalized: Int
  s3OutputPrefix: String
  sampleId: Int
  sfnExecutionArn: String
  subsample: Int
  timeToFinalized: Int
  timeToResultsFinalized: Int
  totalErccReads: Int
  totalReads: Int
  truncated: Int
  unmappedReads: Int
  updatedAt: ISO8601DateTime!
  useTaxonWhitelist: Boolean!
  wdlVersion: String
}

type Project {
  backgroundFlag: Int
  createdAt: ISO8601DateTime!
  creator: User
  daysToKeepSamplePrivate: Int!
  description: String
  id: Int!
  maxInputFragmentsDefault: Int
  name: String!
  publicAccess: Int!
  samples: [Sample!]
  subsampleDefault: Int
  totalSampleCount: Int!
  updatedAt: ISO8601DateTime!
}

type Query @globalOptions(sourceName: "CZIDREST", endpoint: "/") {
  AmrDeprecatedResults(sampleId: String): AmrDeprecatedResults @httpOperation(path: "/samples/{args.sampleId}/amr.json", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: GET)
  AmrWorkflowResults(workflowRunId: String): AmrWorkflowResults @httpOperation(path: "/workflow_runs/{args.workflowRunId}/results", httpMethod: GET)
  Background(snapshotLinkId: String): Background @httpOperation(path: "/pub/{args.snapshotLinkId}/backgrounds.json", httpMethod: GET)
  BulkDownloadCGOverview(input: queryInput_BulkDownloadCGOverview_input_Input): ConsensusGenomeOverviewRows @httpOperation(path: "/bulk_downloads", httpMethod: POST)
  ConsensusGenomeWorkflowResults(workflowRunId: String): ConsensusGenomeWorkflowResults @httpOperation(path: "/workflow_runs/{args.workflowRunId}/results", httpMethod: GET)
  CoverageVizSummary(sampleId: String, snapshotLinkId: String): [query_CoverageVizSummary_items] @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/{args.sampleId}/coverage_viz_summary", httpMethod: GET)
  GraphQLFederationVersion: GraphQLFederationVersion
  MetadataFields(input: queryInput_MetadataFields_input_Input, snapshotLinkId: String): [query_MetadataFields_items] @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/metadata_fields", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: POST)
  MngsWorkflowResults(_backgroundId: String, sampleId: String, snapshotLinkId: String, workflowVersionId: String): MngsWorkflowResults @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/{args.sampleId}.json", httpMethod: GET) @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/{args.sampleId}/report_v2?&id={args.sampleId}&pipeline_version={args.workflowVersionId}&background={args._backgroundId}&merge_nt_nr=false", httpMethod: GET)
  Pathogens(sampleId: String, snapshotLinkId: String, workflowVersionId: String): [query_Pathogens_items] @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/{args.sampleId}/report_v2?&id={args.sampleId}&pipeline_version={args.workflowVersionId}&merge_nt_nr=false", httpMethod: GET)
  PersistedBackground(projectId: String): PersistedBackground @httpOperation(path: "/persisted_backgrounds/{args.projectId}", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: GET)
  PipelineData(sampleId: String, workflowVersionId: String): PipelineData @httpOperation(path: "/samples/{args.sampleId}/pipeline_viz/{args.workflowVersionId}.json", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: GET)
  SampleForReport(railsSampleId: String, snapshotLinkId: String): SampleForReport @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/{args.railsSampleId}.json", httpMethod: GET)
  SampleMetadata(input: queryInput_SampleMetadata_input_Input, sampleId: String, snapshotLinkId: String): SampleMetadata @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/{args.sampleId}/metadata", httpMethod: GET)
  TaxonDist(backgroundId: String, taxonId: String): TaxonDist @httpOperation(path: "/backgrounds/{args.backgroundId}/show_taxon_dist.json?taxid={args.taxonId}", operationSpecificHeaders: "{\\"Cookie\\":\\"{context.headers['cookie']}\\"}", httpMethod: GET)
  Taxons(sampleId: String, snapshotLinkId: String, workflowVersionId: String): [query_Taxons_items] @httpOperation(path: "/pub/{args.snapshotLinkId}/samples/{args.sampleId}/report_v2?&id={args.sampleId}&pipeline_version={args.workflowVersionId}&merge_nt_nr=false", httpMethod: GET)
  UserBlastAnnotations(sampleId: String, workflowVersionId: String): [query_UserBlastAnnotations_items] @httpOperation(path: "/samples/{args.sampleId}/report_v2?&id={args.sampleId}&pipeline_version={args.workflowVersionId}&merge_nt_nr=false", httpMethod: GET)
  ValidateUserCanDeleteObjects(input: queryInput_ValidateUserCanDeleteObjects_input_Input): ValidateUserCanDeleteObjects @httpOperation(path: "/samples/validate_user_can_delete_objects.json", httpMethod: POST)
  ZipLink(workflowRunId: String): ZipLink @httpOperation(path: "/workflow_runs/{args.workflowRunId}/zip_link.json", httpMethod: GET)
  accessions(limitOffset: LimitOffsetClause = null, orderBy: [AccessionOrderByClause!] = [], where: AccessionWhereClause = null): [Accession!]!
  accessionsAggregate(where: AccessionWhereClause = null): AccessionAggregate!
  appConfig(id: ID!): AppConfig
  bulkDownloads(limitOffset: LimitOffsetClause = null, orderBy: [BulkDownloadOrderByClause!] = [], where: BulkDownloadWhereClause = null): [BulkDownload!]!
  bulkDownloadsAggregate(where: BulkDownloadWhereClause = null): BulkDownloadAggregate!
  consensusGenomes(limitOffset: LimitOffsetClause = null, orderBy: [ConsensusGenomeOrderByClause!] = [], where: ConsensusGenomeWhereClause = null): [ConsensusGenome!]!
  consensusGenomesAggregate(where: ConsensusGenomeWhereClause = null): ConsensusGenomeAggregate!
  fedBulkDownloads(input: queryInput_fedBulkDownloads_input_Input): [query_fedBulkDownloads_items] @httpOperation(path: "/bulk_downloads?searchBy=&n=", httpMethod: GET)
  fedConsensusGenomes(input: queryInput_fedConsensusGenomes_input_Input): [query_fedConsensusGenomes_items] @httpOperation(path: "/workflow_runs.json", httpMethod: GET)
  fedSamples(input: queryInput_fedSamples_input_Input): [query_fedSamples_items] @httpOperation(path: "/workflow_runs.json", httpMethod: GET)
  fedSequencingReads(input: queryInput_fedSequencingReads_input_Input): [query_fedSequencingReads_items] @httpOperation(path: "/workflow_runs.json", httpMethod: GET)
  fedWorkflowRuns(input: queryInput_fedWorkflowRuns_input_Input): [query_fedWorkflowRuns_items] @httpOperation(path: "/workflow_runs.json", httpMethod: POST)
  fedWorkflowRunsAggregate(input: queryInput_fedWorkflowRunsAggregate_input_Input): fedWorkflowRunsAggregate @httpOperation(path: "/projects.json", httpMethod: GET)
  fedWorkflowRunsAggregateTotalCount(input: queryInput_fedWorkflowRunsAggregateTotalCount_input_Input): fedWorkflowRunsAggregateTotalCount @httpOperation(path: "/samples/stats.json", httpMethod: GET)
  files(where: FileWhereClause = null): [File!]!
  genomicRanges(limitOffset: LimitOffsetClause = null, orderBy: [GenomicRangeOrderByClause!] = [], where: GenomicRangeWhereClause = null): [GenomicRange!]!
  genomicRangesAggregate(where: GenomicRangeWhereClause = null): GenomicRangeAggregate!
  hostOrganisms(limitOffset: LimitOffsetClause = null, orderBy: [HostOrganismOrderByClause!] = [], where: HostOrganismWhereClause = null): [HostOrganism!]!
  hostOrganismsAggregate(where: HostOrganismWhereClause = null): HostOrganismAggregate!
  indexFiles(limitOffset: LimitOffsetClause = null, orderBy: [IndexFileOrderByClause!] = [], where: IndexFileWhereClause = null): [IndexFile!]!
  indexFilesAggregate(where: IndexFileWhereClause = null): IndexFileAggregate!
  metadatas(limitOffset: LimitOffsetClause = null, orderBy: [MetadatumOrderByClause!] = [], where: MetadatumWhereClause = null): [Metadatum!]!
  metadatasAggregate(where: MetadatumWhereClause = null): MetadatumAggregate!
  metricsConsensusGenomes(limitOffset: LimitOffsetClause = null, orderBy: [MetricConsensusGenomeOrderByClause!] = [], where: MetricConsensusGenomeWhereClause = null): [MetricConsensusGenome!]!
  metricsConsensusGenomesAggregate(where: MetricConsensusGenomeWhereClause = null): MetricConsensusGenomeAggregate!
  node(
    """The ID of the object."""
    id: GlobalID!
  ): Node!
  nodes(
    """The IDs of the objects."""
    ids: [GlobalID!]!
  ): [Node!]!
  pathogenList(version: String): PathogenList!
  project(id: Int!): Project!
  referenceGenomes(limitOffset: LimitOffsetClause = null, orderBy: [ReferenceGenomeOrderByClause!] = [], where: ReferenceGenomeWhereClause = null): [ReferenceGenome!]!
  referenceGenomesAggregate(where: ReferenceGenomeWhereClause = null): ReferenceGenomeAggregate!
  sample(sampleId: Int!): Sample!
  sampleReadsStats(sampleIds: [String!]!): SampleReadsStatsList!
  samples(limitOffset: LimitOffsetClause = null, orderBy: [SampleOrderByClause!] = [], where: SampleWhereClause = null): [Sample!]!
  samplesAggregate(where: SampleWhereClause = null): SampleAggregate!
  samplesList(annotations: [Annotation!], basic: Boolean, domain: String, hostIds: [Int!], limit: Int, listAllIds: Boolean, location: String, locationV2: [String!], offset: Int, orderBy: String, orderDir: String, projectId: Int, requestedSampleIds: [Int!], sampleIds: [Int!], searchString: String, taxIds: [Int!], taxLevels: [String!], thresholdFilterInfo: String, time: [String!], tissue: [String!], visibility: [String!], workflow: String): SampleList!
  sequencingReads(limitOffset: LimitOffsetClause = null, orderBy: [SequencingReadOrderByClause!] = [], where: SequencingReadWhereClause = null): [SequencingRead!]!
  sequencingReadsAggregate(where: SequencingReadWhereClause = null): SequencingReadAggregate!
  taxa(limitOffset: LimitOffsetClause = null, orderBy: [TaxonOrderByClause!] = [], where: TaxonWhereClause = null): [Taxon!]!
  taxaAggregate(where: TaxonWhereClause = null): TaxonAggregate!
  upstreamDatabases(limitOffset: LimitOffsetClause = null, orderBy: [UpstreamDatabaseOrderByClause!] = [], where: UpstreamDatabaseWhereClause = null): [UpstreamDatabase!]!
  upstreamDatabasesAggregate(where: UpstreamDatabaseWhereClause = null): UpstreamDatabaseAggregate!
  user(archetypes: String!, email: String!, institution: String!, name: String!, role: Int!, segments: String!): User!
  workflowRunEntityInputs(limitOffset: LimitOffsetClause = null, orderBy: [WorkflowRunEntityInputOrderByClause!] = [], where: WorkflowRunEntityInputWhereClause = null): [WorkflowRunEntityInput!]!
  workflowRunEntityInputsAggregate(where: WorkflowRunEntityInputWhereClause = null): WorkflowRunEntityInputAggregate!
  workflowRunSteps(limitOffset: LimitOffsetClause = null, orderBy: [WorkflowRunStepOrderByClause!] = [], where: WorkflowRunStepWhereClause = null): [WorkflowRunStep!]!
  workflowRunStepsAggregate(where: WorkflowRunStepWhereClause = null): WorkflowRunStepAggregate!
  workflowRuns(limitOffset: LimitOffsetClause = null, orderBy: [WorkflowRunOrderByClause!] = [], where: WorkflowRunWhereClause = null): [WorkflowRun!]!
  workflowRunsAggregate(where: WorkflowRunWhereClause = null): WorkflowRunAggregate!
  workflowVersions(limitOffset: LimitOffsetClause = null, orderBy: [WorkflowVersionOrderByClause!] = [], where: WorkflowVersionWhereClause = null): [WorkflowVersion!]!
  workflowVersionsAggregate(where: WorkflowVersionWhereClause = null): WorkflowVersionAggregate!
  workflows(limitOffset: LimitOffsetClause = null, orderBy: [WorkflowOrderByClause!] = [], where: WorkflowWhereClause = null): [Workflow!]!
  workflowsAggregate(where: WorkflowWhereClause = null): WorkflowAggregate!
}

type ReferenceGenome implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  consensusGenomes(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [ConsensusGenomeOrderByClause!] = []
    where: ConsensusGenomeWhereClause = null
  ): ConsensusGenomeConnection!
  consensusGenomesAggregate(where: ConsensusGenomeWhereClause = null): ConsensusGenomeAggregate
  createdAt: DateTime!
  deletedAt: DateTime
  file(where: FileWhereClause = null): File
  fileId: ID
  id: ID!
  name: String!
  ownerUserId: Int!
  producingRunId: ID
  updatedAt: DateTime
}

type ReferenceGenomeAggregate {
  aggregate: [ReferenceGenomeAggregateFunctions!]
}

type ReferenceGenomeAggregateFunctions {
  avg: ReferenceGenomeNumericalColumns
  count(columns: ReferenceGenomeCountColumns = null, distinct: Boolean = false): Int
  groupBy: ReferenceGenomeGroupByOptions
  max: ReferenceGenomeMinMaxColumns
  min: ReferenceGenomeMinMaxColumns
  stddev: ReferenceGenomeNumericalColumns
  sum: ReferenceGenomeNumericalColumns
  variance: ReferenceGenomeNumericalColumns
}

enum ReferenceGenomeCountColumns {
  collectionId
  consensusGenomes
  createdAt
  deletedAt
  file
  id
  name
  ownerUserId
  producingRunId
  updatedAt
}

input ReferenceGenomeCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  name: String!
  producingRunId: ID = null
}

type ReferenceGenomeGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  id: UUID
  name: String
  ownerUserId: Int
  producingRunId: UUID
  updatedAt: DateTime
}

type ReferenceGenomeMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  name: String
  ownerUserId: Int
  updatedAt: DateTime
}

type ReferenceGenomeNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input ReferenceGenomeOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  id: orderBy
  name: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  updatedAt: orderBy
}

input ReferenceGenomeUpdateInput {
  deletedAt: DateTime = null
  name: String = null
}

input ReferenceGenomeWhereClause {
  collectionId: IntComparators
  consensusGenomes: ConsensusGenomeWhereClause
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  name: StrComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  updatedAt: DatetimeComparators
}

input ReferenceGenomeWhereClauseMutations {
  id: UUIDComparators
}

input RunWorkflowVersionInput {
  collectionId: Int!
  entityInputs: [EntityInputType!]
  railsWorkflowRunId: Int = null
  rawInputJson: String
  workflowVersionId: ID!
}

type Sample implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  alignmentConfigName: String
  basespaceAccessToken: String
  collectionId: Int!
  createdAt: DateTime!
  dagVars: String
  defaultBackgroundId: Int
  defaultPipelineRunId: Int
  deletedAt: DateTime
  details: SampleDetails!
  doNotProcess: Boolean!
  editable: Boolean
  hostGenome: HostGenome
  hostGenomeId: Int
  hostOrganism(orderBy: [HostOrganismOrderByClause!] = [], where: HostOrganismWhereClause = null): HostOrganism
  id: ID!
  initialWorkflow: String!
  maxInputFragments: Int
  metadatas(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [MetadatumOrderByClause!] = []
    where: MetadatumWhereClause = null
  ): MetadatumConnection!
  metadatasAggregate(where: MetadatumWhereClause = null): MetadatumAggregate
  name: String!
  ownerUserId: Int!
  pipelineBranch: String
  pipelineCommit: String
  pipelineExecutionStrategy: String
  pipelineRuns: [PipelineRun!]
  privateUntil: ISO8601DateTime
  producingRunId: ID
  project: Project
  projectId: Int
  public: Int!
  railsSampleId: Int
  s3Bowtie2IndexPath: String
  s3PreloadResultPath: String
  s3StarIndexPath: String
  sampleDeletable: Boolean
  sampleNotes: String
  sequencingReads(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [SequencingReadOrderByClause!] = []
    where: SequencingReadWhereClause = null
  ): SequencingReadConnection!
  sequencingReadsAggregate(where: SequencingReadWhereClause = null): SequencingReadAggregate
  status: String
  subsample: Int
  updatedAt: DateTime
  uploadError: String
  uploadedFromBasespace: Int
  useTaxonWhitelist: Boolean!
  user: User
  userId: Int
  webCommit: String
  workflowRuns: [WorkflowRun!]
}

type SampleAggregate {
  aggregate: [SampleAggregateFunctions!]
}

type SampleAggregateFunctions {
  avg: SampleNumericalColumns
  count(columns: SampleCountColumns = null, distinct: Boolean = false): Int
  groupBy: SampleGroupByOptions
  max: SampleMinMaxColumns
  min: SampleMinMaxColumns
  stddev: SampleNumericalColumns
  sum: SampleNumericalColumns
  variance: SampleNumericalColumns
}

"""A connection to a list of items."""
type SampleConnection {
  """Contains the nodes in this connection"""
  edges: [SampleEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum SampleCountColumns {
  collectionId
  createdAt
  deletedAt
  hostOrganism
  id
  metadatas
  name
  ownerUserId
  producingRunId
  railsSampleId
  sequencingReads
  updatedAt
}

input SampleCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  hostOrganismId: ID = null
  name: String!
  producingRunId: ID = null
  railsSampleId: Int = null
}

type SampleDetails {
  dbSample: DbSample
  derivedSampleOutput: DerivedSampleOutput
  metadata: SampleMetadata
  mngsRunInfo: MngsRunInfo
  uploader: SampleUploader!
  workflowRunsCountByWorkflow: String
}

"""An edge in a connection."""
type SampleEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Sample!
}

type SampleForReport {
  created_at: String
  default_background_id: Int
  default_pipeline_run_id: String
  editable: Boolean
  host_genome_id: Int
  id: String
  initial_workflow: String
  name: String
  pipeline_runs: [query_SampleForReport_pipeline_runs_items]
  project: query_SampleForReport_project
  project_id: Int
  railsSampleId: String
  status: String
  updated_at: String
  upload_error: String
  user_id: Int
  workflow_runs: [query_SampleForReport_workflow_runs_items]
}

type SampleGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  hostOrganism: HostOrganismGroupByOptions
  id: UUID
  name: String
  ownerUserId: Int
  producingRunId: UUID
  railsSampleId: Int
  updatedAt: DateTime
}

type SampleList {
  sampleIds: [Int!]
  samples: [Sample!]!
}

type SampleMetadata {
  additional_info: query_SampleMetadata_additional_info
  collectionDate: String
  collectionLocationV2: String
  metadata: [query_SampleMetadata_metadata_items]
  nucleotideType: String
  sampleType: String
  waterControl: String
}

type SampleMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  name: String
  ownerUserId: Int
  railsSampleId: Int
  updatedAt: DateTime
}

type SampleNumericalColumns {
  collectionId: Int
  ownerUserId: Int
  railsSampleId: Int
}

input SampleOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  hostOrganism: HostOrganismOrderByClause
  id: orderBy
  name: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  railsSampleId: orderBy
  updatedAt: orderBy
}

type SampleReadsStats {
  initialReads: Int
  name: String
  pipelineVersion: String
  sampleId: ID!
  steps: [SampleSteps!]
  wdlVersion: String
}

type SampleReadsStatsList {
  sampleReadsStats: [SampleReadsStats!]!
}

type SampleSteps {
  name: String
  readsAfter: Int
}

type SampleSummaryStats {
  adjustedRemainingReads: Int
  compressionRatio: Float
  insertSizeMean: Float
  insertSizeStandardDeviation: Float
  lastProcessedAt: ISO8601DateTime
  percentRemaining: Float
  qcPercent: Float
  readsAfterCzidDedup: Int
  readsAfterPriceseq: Int
  readsAfterStar: Int
  readsAfterTrimmomatic: Int
  unmappedReads: Int
}

input SampleUpdateInput {
  deletedAt: DateTime = null
  name: String = null
}

type SampleUploader {
  id: Int!
  name: String
}

input SampleWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  hostOrganism: HostOrganismWhereClause
  id: UUIDComparators
  metadatas: MetadatumWhereClause
  name: StrComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  railsSampleId: IntComparators
  sequencingReads: SequencingReadWhereClause
  updatedAt: DatetimeComparators
}

input SampleWhereClauseMutations {
  id: UUIDComparators
}

enum SequencingProtocol {
  ampliseq
  artic
  artic_v3
  artic_v4
  artic_v5
  combined_msspe_artic
  covidseq
  easyseq
  midnight
  msspe
  snap
  varskip
}

input SequencingProtocolEnumComparators {
  _eq: SequencingProtocol
  _gt: SequencingProtocol
  _gte: SequencingProtocol
  _in: [SequencingProtocol!]
  _is_null: Boolean
  _lt: SequencingProtocol
  _lte: SequencingProtocol
  _neq: SequencingProtocol
  _nin: [SequencingProtocol!]
}

type SequencingRead implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  clearlabsExport: Boolean!
  collectionId: Int!
  consensusGenomes(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [ConsensusGenomeOrderByClause!] = []
    where: ConsensusGenomeWhereClause = null
  ): ConsensusGenomeConnection!
  consensusGenomesAggregate(where: ConsensusGenomeWhereClause = null): ConsensusGenomeAggregate
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  medakaModel: String
  ownerUserId: Int!
  primerFile(orderBy: [GenomicRangeOrderByClause!] = [], where: GenomicRangeWhereClause = null): GenomicRange
  producingRunId: ID
  protocol: SequencingProtocol
  r1File(where: FileWhereClause = null): File
  r1FileId: ID
  r2File(where: FileWhereClause = null): File
  r2FileId: ID
  sample(orderBy: [SampleOrderByClause!] = [], where: SampleWhereClause = null): Sample
  taxon(orderBy: [TaxonOrderByClause!] = [], where: TaxonWhereClause = null): Taxon
  technology: SequencingTechnology!
  updatedAt: DateTime
}

type SequencingReadAggregate {
  aggregate: [SequencingReadAggregateFunctions!]
}

type SequencingReadAggregateFunctions {
  avg: SequencingReadNumericalColumns
  count(columns: SequencingReadCountColumns = null, distinct: Boolean = false): Int
  groupBy: SequencingReadGroupByOptions
  max: SequencingReadMinMaxColumns
  min: SequencingReadMinMaxColumns
  stddev: SequencingReadNumericalColumns
  sum: SequencingReadNumericalColumns
  variance: SequencingReadNumericalColumns
}

"""A connection to a list of items."""
type SequencingReadConnection {
  """Contains the nodes in this connection"""
  edges: [SequencingReadEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum SequencingReadCountColumns {
  clearlabsExport
  collectionId
  consensusGenomes
  createdAt
  deletedAt
  id
  medakaModel
  ownerUserId
  primerFile
  producingRunId
  protocol
  r1File
  r2File
  sample
  taxon
  technology
  updatedAt
}

input SequencingReadCreateInput {
  clearlabsExport: Boolean!
  collectionId: Int!
  deletedAt: DateTime = null
  medakaModel: String = null
  primerFileId: ID = null
  producingRunId: ID = null
  protocol: SequencingProtocol = null
  sampleId: ID = null
  taxonId: ID = null
  technology: SequencingTechnology!
}

"""An edge in a connection."""
type SequencingReadEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: SequencingRead!
}

type SequencingReadGroupByOptions {
  clearlabsExport: Boolean
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  id: UUID
  medakaModel: String
  ownerUserId: Int
  primerFile: GenomicRangeGroupByOptions
  producingRunId: UUID
  protocol: SequencingProtocol
  sample: SampleGroupByOptions
  taxon: TaxonGroupByOptions
  technology: SequencingTechnology
  updatedAt: DateTime
}

type SequencingReadMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  medakaModel: String
  ownerUserId: Int
  updatedAt: DateTime
}

type SequencingReadNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input SequencingReadOrderByClause {
  clearlabsExport: orderBy
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  id: orderBy
  medakaModel: orderBy
  ownerUserId: orderBy
  primerFile: GenomicRangeOrderByClause
  producingRunId: orderBy
  protocol: orderBy
  sample: SampleOrderByClause
  taxon: TaxonOrderByClause
  technology: orderBy
  updatedAt: orderBy
}

input SequencingReadUpdateInput {
  clearlabsExport: Boolean = null
  deletedAt: DateTime = null
  medakaModel: String = null
  primerFileId: ID = null
}

input SequencingReadWhereClause {
  clearlabsExport: BoolComparators
  collectionId: IntComparators
  consensusGenomes: ConsensusGenomeWhereClause
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  medakaModel: StrComparators
  ownerUserId: IntComparators
  primerFile: GenomicRangeWhereClause
  producingRunId: UUIDComparators
  protocol: SequencingProtocolEnumComparators
  sample: SampleWhereClause
  taxon: TaxonWhereClause
  technology: SequencingTechnologyEnumComparators
  updatedAt: DatetimeComparators
}

input SequencingReadWhereClauseMutations {
  id: UUIDComparators
}

enum SequencingTechnology {
  Illumina
  Nanopore
}

input SequencingTechnologyEnumComparators {
  _eq: SequencingTechnology
  _gt: SequencingTechnology
  _gte: SequencingTechnology
  _in: [SequencingTechnology!]
  _is_null: Boolean
  _lt: SequencingTechnology
  _lte: SequencingTechnology
  _neq: SequencingTechnology
  _nin: [SequencingTechnology!]
}

type SignedURL {
  expiration: Int!
  fields: JSON
  method: String!
  protocol: String!
  url: String!
}

input StrComparators {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _iregex: String
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _niregex: String
  _nlike: String
  _nregex: String
  _regex: String
}

type Taxon implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  commonName: String
  consensusGenomes(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [ConsensusGenomeOrderByClause!] = []
    where: ConsensusGenomeWhereClause = null
  ): ConsensusGenomeConnection!
  consensusGenomesAggregate(where: ConsensusGenomeWhereClause = null): ConsensusGenomeAggregate
  createdAt: DateTime!
  deletedAt: DateTime
  description: String
  id: ID!
  isPhage: Boolean!
  level: TaxonLevel!
  name: String!
  ownerUserId: Int!
  producingRunId: ID
  sequencingReads(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [SequencingReadOrderByClause!] = []
    where: SequencingReadWhereClause = null
  ): SequencingReadConnection!
  sequencingReadsAggregate(where: SequencingReadWhereClause = null): SequencingReadAggregate
  updatedAt: DateTime
  upstreamDatabase(orderBy: [UpstreamDatabaseOrderByClause!] = [], where: UpstreamDatabaseWhereClause = null): UpstreamDatabase
  upstreamDatabaseIdentifier: String!
  wikipediaId: String
}

type TaxonAggregate {
  aggregate: [TaxonAggregateFunctions!]
}

type TaxonAggregateFunctions {
  avg: TaxonNumericalColumns
  count(columns: TaxonCountColumns = null, distinct: Boolean = false): Int
  groupBy: TaxonGroupByOptions
  max: TaxonMinMaxColumns
  min: TaxonMinMaxColumns
  stddev: TaxonNumericalColumns
  sum: TaxonNumericalColumns
  variance: TaxonNumericalColumns
}

"""A connection to a list of items."""
type TaxonConnection {
  """Contains the nodes in this connection"""
  edges: [TaxonEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum TaxonCountColumns {
  collectionId
  commonName
  consensusGenomes
  createdAt
  deletedAt
  description
  id
  isPhage
  level
  name
  ownerUserId
  producingRunId
  sequencingReads
  taxClass
  taxFamily
  taxGenus
  taxKingdom
  taxOrder
  taxParent
  taxPhylum
  taxSpecies
  taxSuperkingdom
  updatedAt
  upstreamDatabase
  upstreamDatabaseIdentifier
  wikipediaId
}

input TaxonCreateInput {
  collectionId: Int!
  commonName: String = null
  deletedAt: DateTime = null
  description: String = null
  isPhage: Boolean!
  level: TaxonLevel!
  name: String!
  producingRunId: ID = null
  taxClassId: ID = null
  taxFamilyId: ID = null
  taxGenusId: ID = null
  taxKingdomId: ID = null
  taxOrderId: ID = null
  taxParentId: ID = null
  taxPhylumId: ID = null
  taxSpeciesId: ID = null
  taxSuperkingdomId: ID = null
  upstreamDatabaseId: ID!
  upstreamDatabaseIdentifier: String!
  wikipediaId: String = null
}

type TaxonDist {
  NR: query_TaxonDist_NR
  NT: query_TaxonDist_NT
  merged_NT_NR: query_TaxonDist_merged_NT_NR
}

"""An edge in a connection."""
type TaxonEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Taxon!
}

type TaxonGroupByOptions {
  collectionId: Int
  commonName: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: UUID
  isPhage: Boolean
  level: TaxonLevel
  name: String
  ownerUserId: Int
  producingRunId: UUID
  taxClass: TaxonGroupByOptions
  taxFamily: TaxonGroupByOptions
  taxGenus: TaxonGroupByOptions
  taxKingdom: TaxonGroupByOptions
  taxOrder: TaxonGroupByOptions
  taxParent: TaxonGroupByOptions
  taxPhylum: TaxonGroupByOptions
  taxSpecies: TaxonGroupByOptions
  taxSuperkingdom: TaxonGroupByOptions
  updatedAt: DateTime
  upstreamDatabase: UpstreamDatabaseGroupByOptions
  upstreamDatabaseIdentifier: String
  wikipediaId: String
}

enum TaxonLevel {
  level_class
  level_family
  level_genus
  level_kingdom
  level_order
  level_phylum
  level_species
  level_sublevel
  level_superkingdom
}

input TaxonLevelEnumComparators {
  _eq: TaxonLevel
  _gt: TaxonLevel
  _gte: TaxonLevel
  _in: [TaxonLevel!]
  _is_null: Boolean
  _lt: TaxonLevel
  _lte: TaxonLevel
  _neq: TaxonLevel
  _nin: [TaxonLevel!]
}

type TaxonMinMaxColumns {
  collectionId: Int
  commonName: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  name: String
  ownerUserId: Int
  updatedAt: DateTime
  upstreamDatabaseIdentifier: String
  wikipediaId: String
}

type TaxonNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input TaxonOrderByClause {
  collectionId: orderBy
  commonName: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  description: orderBy
  id: orderBy
  isPhage: orderBy
  level: orderBy
  name: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  taxClass: orderBy
  taxFamily: orderBy
  taxGenus: orderBy
  taxKingdom: orderBy
  taxOrder: orderBy
  taxParent: orderBy
  taxPhylum: orderBy
  taxSpecies: orderBy
  taxSuperkingdom: orderBy
  updatedAt: orderBy
  upstreamDatabase: UpstreamDatabaseOrderByClause
  upstreamDatabaseIdentifier: orderBy
  wikipediaId: orderBy
}

input TaxonUpdateInput {
  commonName: String = null
  deletedAt: DateTime = null
  description: String = null
  isPhage: Boolean = null
  level: TaxonLevel = null
  taxClassId: ID = null
  taxFamilyId: ID = null
  taxGenusId: ID = null
  taxKingdomId: ID = null
  taxOrderId: ID = null
  taxParentId: ID = null
  taxPhylumId: ID = null
  taxSpeciesId: ID = null
  taxSuperkingdomId: ID = null
  wikipediaId: String = null
}

input TaxonWhereClause {
  collectionId: IntComparators
  commonName: StrComparators
  consensusGenomes: ConsensusGenomeWhereClause
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  description: StrComparators
  id: UUIDComparators
  isPhage: BoolComparators
  level: TaxonLevelEnumComparators
  name: StrComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  sequencingReads: SequencingReadWhereClause
  taxClassId: UUIDComparators
  taxFamilyId: UUIDComparators
  taxGenusId: UUIDComparators
  taxKingdomId: UUIDComparators
  taxOrderId: UUIDComparators
  taxParentId: UUIDComparators
  taxPhylumId: UUIDComparators
  taxSpeciesId: UUIDComparators
  taxSuperkingdomId: UUIDComparators
  updatedAt: DatetimeComparators
  upstreamDatabase: UpstreamDatabaseWhereClause
  upstreamDatabaseIdentifier: StrComparators
  wikipediaId: StrComparators
}

input TaxonWhereClauseMutations {
  id: UUIDComparators
}

scalar UUID

input UUIDComparators {
  _eq: UUID
  _gt: UUID
  _gte: UUID
  _in: [UUID!]
  _is_null: Boolean
  _lt: UUID
  _lte: UUID
  _neq: UUID
  _nin: [UUID!]
}

type UpdateMetadataReponse {
  message: String
  status: String
}

type UpdateSampleName {
  message: String
  status: String
}

type UpdateSampleNotes {
  message: String
  status: String
}

type UpstreamDatabase implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  accessions(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [AccessionOrderByClause!] = []
    where: AccessionWhereClause = null
  ): AccessionConnection!
  accessionsAggregate(where: AccessionWhereClause = null): AccessionAggregate
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  indexes(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [IndexFileOrderByClause!] = []
    where: IndexFileWhereClause = null
  ): IndexFileConnection!
  indexesAggregate(where: IndexFileWhereClause = null): IndexFileAggregate
  name: String!
  ownerUserId: Int!
  producingRunId: ID
  taxa(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [TaxonOrderByClause!] = []
    where: TaxonWhereClause = null
  ): TaxonConnection!
  taxaAggregate(where: TaxonWhereClause = null): TaxonAggregate
  updatedAt: DateTime
}

type UpstreamDatabaseAggregate {
  aggregate: [UpstreamDatabaseAggregateFunctions!]
}

type UpstreamDatabaseAggregateFunctions {
  avg: UpstreamDatabaseNumericalColumns
  count(columns: UpstreamDatabaseCountColumns = null, distinct: Boolean = false): Int
  groupBy: UpstreamDatabaseGroupByOptions
  max: UpstreamDatabaseMinMaxColumns
  min: UpstreamDatabaseMinMaxColumns
  stddev: UpstreamDatabaseNumericalColumns
  sum: UpstreamDatabaseNumericalColumns
  variance: UpstreamDatabaseNumericalColumns
}

enum UpstreamDatabaseCountColumns {
  accessions
  collectionId
  createdAt
  deletedAt
  id
  indexes
  name
  ownerUserId
  producingRunId
  taxa
  updatedAt
}

input UpstreamDatabaseCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  name: String!
  producingRunId: ID = null
}

type UpstreamDatabaseGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  id: UUID
  name: String
  ownerUserId: Int
  producingRunId: UUID
  updatedAt: DateTime
}

type UpstreamDatabaseMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  name: String
  ownerUserId: Int
  updatedAt: DateTime
}

type UpstreamDatabaseNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input UpstreamDatabaseOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  id: orderBy
  name: orderBy
  ownerUserId: orderBy
  producingRunId: orderBy
  updatedAt: orderBy
}

input UpstreamDatabaseUpdateInput {
  deletedAt: DateTime = null
  name: String = null
}

input UpstreamDatabaseWhereClause {
  accessions: AccessionWhereClause
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  indexes: IndexFileWhereClause
  name: StrComparators
  ownerUserId: IntComparators
  producingRunId: UUIDComparators
  taxa: TaxonWhereClause
  updatedAt: DatetimeComparators
}

input UpstreamDatabaseWhereClauseMutations {
  id: UUIDComparators
}

type User {
  archetypes: String!
  createdByUserId: BigInt!
  email: String!
  id: ID!
  institution: String!
  name: String!
  role: Int!
  segments: String!
}

type ValidateUserCanDeleteObjects {
  error: String
  invalidSampleNames: [String]!
  validIds: [Int]!
}

type Workflow implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  defaultVersion: String
  deletedAt: DateTime
  id: ID!
  minimumSupportedVersion: String
  name: String
  ownerUserId: Int!
  updatedAt: DateTime
  versions(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [WorkflowVersionOrderByClause!] = []
    where: WorkflowVersionWhereClause = null
  ): WorkflowVersionConnection!
  versionsAggregate(where: WorkflowVersionWhereClause = null): WorkflowVersionAggregate
}

type WorkflowAggregate {
  aggregate: [WorkflowAggregateFunctions!]
}

type WorkflowAggregateFunctions {
  avg: WorkflowNumericalColumns
  count(columns: WorkflowCountColumns = null, distinct: Boolean = false): Int
  groupBy: WorkflowGroupByOptions
  max: WorkflowMinMaxColumns
  min: WorkflowMinMaxColumns
  stddev: WorkflowNumericalColumns
  sum: WorkflowNumericalColumns
  variance: WorkflowNumericalColumns
}

enum WorkflowCountColumns {
  collectionId
  createdAt
  defaultVersion
  deletedAt
  id
  minimumSupportedVersion
  name
  ownerUserId
  updatedAt
  versions
}

input WorkflowCreateInput {
  collectionId: Int!
  defaultVersion: String = null
  deletedAt: DateTime = null
  minimumSupportedVersion: String = null
  name: String = null
}

type WorkflowGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  defaultVersion: String
  deletedAt: DateTime
  id: UUID
  minimumSupportedVersion: String
  name: String
  ownerUserId: Int
  updatedAt: DateTime
}

type WorkflowMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  defaultVersion: String
  deletedAt: DateTime
  minimumSupportedVersion: String
  name: String
  ownerUserId: Int
  updatedAt: DateTime
}

type WorkflowNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input WorkflowOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  defaultVersion: orderBy
  deletedAt: orderBy
  id: orderBy
  minimumSupportedVersion: orderBy
  name: orderBy
  ownerUserId: orderBy
  updatedAt: orderBy
}

type WorkflowRun implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  cachedResults: String
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  deprecated: Boolean!
  endedAt: DateTime
  entityInputs(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [WorkflowRunEntityInputOrderByClause!] = []
    where: WorkflowRunEntityInputWhereClause = null
  ): WorkflowRunEntityInputConnection!
  entityInputsAggregate(where: WorkflowRunEntityInputWhereClause = null): WorkflowRunEntityInputAggregate
  errorMessage: String
  executedAt: ISO8601DateTime
  executionId: String
  id: ID!
  inputsJson: String
  outputsJson: String
  ownerUserId: Int!
  railsWorkflowRunId: Int
  rawInputsJson: String
  rerunFrom: Int
  s3OutputPrefix: String
  sample: Sample
  sampleId: Int
  sfnExecutionArn: String
  startedAt: DateTime
  status: WorkflowRunStatus
  steps(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [WorkflowRunStepOrderByClause!] = []
    where: WorkflowRunStepWhereClause = null
  ): WorkflowRunStepConnection!
  stepsAggregate(where: WorkflowRunStepWhereClause = null): WorkflowRunStepAggregate
  timeToFinalized: Int
  updatedAt: DateTime
  wdlVersion: String
  workflow: String!
  workflowRunnerInputsJson: String
  workflowVersion(orderBy: [WorkflowVersionOrderByClause!] = [], where: WorkflowVersionWhereClause = null): WorkflowVersion
}

type WorkflowRunAggregate {
  aggregate: [WorkflowRunAggregateFunctions!]
}

type WorkflowRunAggregateFunctions {
  avg: WorkflowRunNumericalColumns
  count(columns: WorkflowRunCountColumns = null, distinct: Boolean = false): Int
  groupBy: WorkflowRunGroupByOptions
  max: WorkflowRunMinMaxColumns
  min: WorkflowRunMinMaxColumns
  stddev: WorkflowRunNumericalColumns
  sum: WorkflowRunNumericalColumns
  variance: WorkflowRunNumericalColumns
}

"""A connection to a list of items."""
type WorkflowRunConnection {
  """Contains the nodes in this connection"""
  edges: [WorkflowRunEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum WorkflowRunCountColumns {
  collectionId
  createdAt
  deletedAt
  deprecatedBy
  endedAt
  entityInputs
  errorMessage
  executionId
  id
  outputsJson
  ownerUserId
  railsWorkflowRunId
  rawInputsJson
  startedAt
  status
  steps
  updatedAt
  workflowRunnerInputsJson
  workflowVersion
}

"""An edge in a connection."""
type WorkflowRunEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: WorkflowRun!
}

type WorkflowRunEntityInput implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  entityType: String
  fieldName: String
  id: ID!
  inputEntityId: ID
  ownerUserId: Int!
  updatedAt: DateTime
  workflowRun(orderBy: [WorkflowRunOrderByClause!] = [], where: WorkflowRunWhereClause = null): WorkflowRun
}

type WorkflowRunEntityInputAggregate {
  aggregate: [WorkflowRunEntityInputAggregateFunctions!]
}

type WorkflowRunEntityInputAggregateFunctions {
  avg: WorkflowRunEntityInputNumericalColumns
  count(columns: WorkflowRunEntityInputCountColumns = null, distinct: Boolean = false): Int
  groupBy: WorkflowRunEntityInputGroupByOptions
  max: WorkflowRunEntityInputMinMaxColumns
  min: WorkflowRunEntityInputMinMaxColumns
  stddev: WorkflowRunEntityInputNumericalColumns
  sum: WorkflowRunEntityInputNumericalColumns
  variance: WorkflowRunEntityInputNumericalColumns
}

"""A connection to a list of items."""
type WorkflowRunEntityInputConnection {
  """Contains the nodes in this connection"""
  edges: [WorkflowRunEntityInputEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum WorkflowRunEntityInputCountColumns {
  collectionId
  createdAt
  deletedAt
  entityType
  fieldName
  id
  inputEntityId
  ownerUserId
  updatedAt
  workflowRun
}

input WorkflowRunEntityInputCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  entityType: String = null
  fieldName: String = null
  inputEntityId: ID = null
  workflowRunId: ID = null
}

"""An edge in a connection."""
type WorkflowRunEntityInputEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: WorkflowRunEntityInput!
}

type WorkflowRunEntityInputGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  entityType: String
  fieldName: String
  id: UUID
  inputEntityId: UUID
  ownerUserId: Int
  updatedAt: DateTime
  workflowRun: WorkflowRunGroupByOptions
}

type WorkflowRunEntityInputMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  entityType: String
  fieldName: String
  ownerUserId: Int
  updatedAt: DateTime
}

type WorkflowRunEntityInputNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input WorkflowRunEntityInputOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  entityType: orderBy
  fieldName: orderBy
  id: orderBy
  inputEntityId: orderBy
  ownerUserId: orderBy
  updatedAt: orderBy
  workflowRun: WorkflowRunOrderByClause
}

input WorkflowRunEntityInputWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  entityType: StrComparators
  fieldName: StrComparators
  id: UUIDComparators
  inputEntityId: UUIDComparators
  ownerUserId: IntComparators
  updatedAt: DatetimeComparators
  workflowRun: WorkflowRunWhereClause
}

input WorkflowRunEntityInputWhereClauseMutations {
  id: UUIDComparators
}

type WorkflowRunGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  deprecatedBy: WorkflowRunGroupByOptions
  endedAt: DateTime
  errorMessage: String
  executionId: String
  id: UUID
  outputsJson: String
  ownerUserId: Int
  railsWorkflowRunId: Int
  rawInputsJson: String
  startedAt: DateTime
  status: WorkflowRunStatus
  updatedAt: DateTime
  workflowRunnerInputsJson: String
  workflowVersion: WorkflowVersionGroupByOptions
}

type WorkflowRunMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  endedAt: DateTime
  errorMessage: String
  executionId: String
  outputsJson: String
  ownerUserId: Int
  railsWorkflowRunId: Int
  rawInputsJson: String
  startedAt: DateTime
  updatedAt: DateTime
  workflowRunnerInputsJson: String
}

type WorkflowRunNumericalColumns {
  collectionId: Int
  ownerUserId: Int
  railsWorkflowRunId: Int
}

input WorkflowRunOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  deprecatedBy: orderBy
  endedAt: orderBy
  errorMessage: orderBy
  executionId: orderBy
  id: orderBy
  outputsJson: orderBy
  ownerUserId: orderBy
  railsWorkflowRunId: orderBy
  rawInputsJson: orderBy
  startedAt: orderBy
  status: orderBy
  updatedAt: orderBy
  workflowRunnerInputsJson: orderBy
  workflowVersion: WorkflowVersionOrderByClause
}

enum WorkflowRunStatus {
  ABORTED
  CREATED
  FAILED
  PENDING
  RUNNING
  STARTED
  SUCCEEDED
  SUCCEEDED_WITH_ISSUE
  TIMED_OUT
}

input WorkflowRunStatusEnumComparators {
  _eq: WorkflowRunStatus
  _gt: WorkflowRunStatus
  _gte: WorkflowRunStatus
  _in: [WorkflowRunStatus!]
  _is_null: Boolean
  _lt: WorkflowRunStatus
  _lte: WorkflowRunStatus
  _neq: WorkflowRunStatus
  _nin: [WorkflowRunStatus!]
}

type WorkflowRunStep implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  endedAt: DateTime
  id: ID!
  ownerUserId: Int!
  startedAt: DateTime
  status: WorkflowRunStepStatus
  updatedAt: DateTime
  workflowRun(orderBy: [WorkflowRunOrderByClause!] = [], where: WorkflowRunWhereClause = null): WorkflowRun
}

type WorkflowRunStepAggregate {
  aggregate: [WorkflowRunStepAggregateFunctions!]
}

type WorkflowRunStepAggregateFunctions {
  avg: WorkflowRunStepNumericalColumns
  count(columns: WorkflowRunStepCountColumns = null, distinct: Boolean = false): Int
  groupBy: WorkflowRunStepGroupByOptions
  max: WorkflowRunStepMinMaxColumns
  min: WorkflowRunStepMinMaxColumns
  stddev: WorkflowRunStepNumericalColumns
  sum: WorkflowRunStepNumericalColumns
  variance: WorkflowRunStepNumericalColumns
}

"""A connection to a list of items."""
type WorkflowRunStepConnection {
  """Contains the nodes in this connection"""
  edges: [WorkflowRunStepEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum WorkflowRunStepCountColumns {
  collectionId
  createdAt
  deletedAt
  endedAt
  id
  ownerUserId
  startedAt
  status
  updatedAt
  workflowRun
}

input WorkflowRunStepCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  endedAt: DateTime = null
  status: WorkflowRunStepStatus = null
  workflowRunId: ID = null
}

"""An edge in a connection."""
type WorkflowRunStepEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: WorkflowRunStep!
}

type WorkflowRunStepGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  endedAt: DateTime
  id: UUID
  ownerUserId: Int
  startedAt: DateTime
  status: WorkflowRunStepStatus
  updatedAt: DateTime
  workflowRun: WorkflowRunGroupByOptions
}

type WorkflowRunStepMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  endedAt: DateTime
  ownerUserId: Int
  startedAt: DateTime
  updatedAt: DateTime
}

type WorkflowRunStepNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input WorkflowRunStepOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  endedAt: orderBy
  id: orderBy
  ownerUserId: orderBy
  startedAt: orderBy
  status: orderBy
  updatedAt: orderBy
  workflowRun: WorkflowRunOrderByClause
}

enum WorkflowRunStepStatus {
  FAILED
  RUNNING
  SUCCEEDED
}

input WorkflowRunStepStatusEnumComparators {
  _eq: WorkflowRunStepStatus
  _gt: WorkflowRunStepStatus
  _gte: WorkflowRunStepStatus
  _in: [WorkflowRunStepStatus!]
  _is_null: Boolean
  _lt: WorkflowRunStepStatus
  _lte: WorkflowRunStepStatus
  _neq: WorkflowRunStepStatus
  _nin: [WorkflowRunStepStatus!]
}

input WorkflowRunStepUpdateInput {
  deletedAt: DateTime = null
  endedAt: DateTime = null
  status: WorkflowRunStepStatus = null
}

input WorkflowRunStepWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  endedAt: DatetimeComparators
  id: UUIDComparators
  ownerUserId: IntComparators
  startedAt: DatetimeComparators
  status: WorkflowRunStepStatusEnumComparators
  updatedAt: DatetimeComparators
  workflowRun: WorkflowRunWhereClause
}

input WorkflowRunStepWhereClauseMutations {
  id: UUIDComparators
}

input WorkflowRunUpdateInput {
  deletedAt: DateTime = null
  deprecatedById: ID = null
  endedAt: DateTime = null
  errorMessage: String = null
  executionId: String = null
  outputsJson: String = null
  status: WorkflowRunStatus = null
  workflowRunnerInputsJson: String = null
}

input WorkflowRunWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  deprecatedById: UUIDComparators
  endedAt: DatetimeComparators
  entityInputs: WorkflowRunEntityInputWhereClause
  errorMessage: StrComparators
  executionId: StrComparators
  id: UUIDComparators
  outputsJson: StrComparators
  ownerUserId: IntComparators
  railsWorkflowRunId: IntComparators
  rawInputsJson: StrComparators
  startedAt: DatetimeComparators
  status: WorkflowRunStatusEnumComparators
  steps: WorkflowRunStepWhereClause
  updatedAt: DatetimeComparators
  workflowRunnerInputsJson: StrComparators
  workflowVersion: WorkflowVersionWhereClause
}

input WorkflowRunWhereClauseMutations {
  id: UUIDComparators
}

input WorkflowUpdateInput {
  defaultVersion: String = null
  deletedAt: DateTime = null
  minimumSupportedVersion: String = null
  name: String = null
}

type WorkflowVersion implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  collectionId: Int!
  createdAt: DateTime!
  deletedAt: DateTime
  deprecated: Boolean
  graphJson: String
  id: ID!
  manifest: String
  ownerUserId: Int!
  runs(
    """Returns the items in the list that come after the specified cursor."""
    after: String = null
    """Returns the items in the list that come before the specified cursor."""
    before: String = null
    """Returns the first n items from the list."""
    first: Int = null
    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    orderBy: [WorkflowRunOrderByClause!] = []
    where: WorkflowRunWhereClause = null
  ): WorkflowRunConnection!
  runsAggregate(where: WorkflowRunWhereClause = null): WorkflowRunAggregate
  updatedAt: DateTime
  version: String
  workflow(orderBy: [WorkflowOrderByClause!] = [], where: WorkflowWhereClause = null): Workflow
  workflowUri: String
}

type WorkflowVersionAggregate {
  aggregate: [WorkflowVersionAggregateFunctions!]
}

type WorkflowVersionAggregateFunctions {
  avg: WorkflowVersionNumericalColumns
  count(columns: WorkflowVersionCountColumns = null, distinct: Boolean = false): Int
  groupBy: WorkflowVersionGroupByOptions
  max: WorkflowVersionMinMaxColumns
  min: WorkflowVersionMinMaxColumns
  stddev: WorkflowVersionNumericalColumns
  sum: WorkflowVersionNumericalColumns
  variance: WorkflowVersionNumericalColumns
}

"""A connection to a list of items."""
type WorkflowVersionConnection {
  """Contains the nodes in this connection"""
  edges: [WorkflowVersionEdge!]!
  """Pagination data for this connection"""
  pageInfo: PageInfo!
}

enum WorkflowVersionCountColumns {
  collectionId
  createdAt
  deletedAt
  deprecated
  graphJson
  id
  manifest
  ownerUserId
  runs
  updatedAt
  version
  workflow
  workflowUri
}

input WorkflowVersionCreateInput {
  collectionId: Int!
  deletedAt: DateTime = null
  deprecated: Boolean = null
  graphJson: String = null
  manifest: String = null
  version: String = null
  workflowId: ID = null
  workflowUri: String = null
}

"""An edge in a connection."""
type WorkflowVersionEdge {
  """A cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: WorkflowVersion!
}

type WorkflowVersionGroupByOptions {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  deprecated: Boolean
  graphJson: String
  id: UUID
  manifest: String
  ownerUserId: Int
  updatedAt: DateTime
  version: String
  workflow: WorkflowGroupByOptions
  workflowUri: String
}

type WorkflowVersionMinMaxColumns {
  collectionId: Int
  createdAt: DateTime
  deletedAt: DateTime
  graphJson: String
  manifest: String
  ownerUserId: Int
  updatedAt: DateTime
  version: String
  workflowUri: String
}

type WorkflowVersionNumericalColumns {
  collectionId: Int
  ownerUserId: Int
}

input WorkflowVersionOrderByClause {
  collectionId: orderBy
  createdAt: orderBy
  deletedAt: orderBy
  deprecated: orderBy
  graphJson: orderBy
  id: orderBy
  manifest: orderBy
  ownerUserId: orderBy
  updatedAt: orderBy
  version: orderBy
  workflow: WorkflowOrderByClause
  workflowUri: orderBy
}

input WorkflowVersionWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  deletedAt: DatetimeComparators
  deprecated: BoolComparators
  graphJson: StrComparators
  id: UUIDComparators
  manifest: StrComparators
  ownerUserId: IntComparators
  runs: WorkflowRunWhereClause
  updatedAt: DatetimeComparators
  version: StrComparators
  workflow: WorkflowWhereClause
  workflowUri: StrComparators
}

input WorkflowVersionWhereClauseMutations {
  id: UUIDComparators
}

input WorkflowWhereClause {
  collectionId: IntComparators
  createdAt: DatetimeComparators
  defaultVersion: StrComparators
  deletedAt: DatetimeComparators
  id: UUIDComparators
  minimumSupportedVersion: StrComparators
  name: StrComparators
  ownerUserId: IntComparators
  updatedAt: DatetimeComparators
  versions: WorkflowVersionWhereClause
}

input WorkflowWhereClauseMutations {
  id: UUIDComparators
}

type ZipLink {
  error: String
  url: String
}

type fedWorkflowRunsAggregate {
  aggregate: [query_fedWorkflowRunsAggregate_aggregate_items]
}

type fedWorkflowRunsAggregateTotalCount {
  aggregate: [query_fedWorkflowRunsAggregateTotalCount_aggregate_items]
}

input mutationInput_CreateBulkDownload_input_Input {
  authenticityToken: String
  downloadFormat: String
  downloadType: String
  workflow: String
  workflowRunIds: [Int]
  workflowRunIdsStrings: [String]
}

input mutationInput_DeleteSamples_input_Input @example(value: "{\\"ids\\":[1],\\"idsStrings\\":[\\"1\\"],\\"workflow\\":\\"short-read-mngs\\",\\"authenticityToken\\":\\"token\\"}") {
  authenticityToken: String
  ids: [Int]
  idsStrings: [String]
  workflow: String
}

input mutationInput_KickoffAMRWorkflow_input_Input @example(value: "{\\"inputs_json\\":{\\"start_from_mngs\\":true},\\"workflow\\":\\"amr\\",\\"authenticityToken\\":\\"token\\"}") {
  authenticityToken: String
  inputs_json: mutationInput_KickoffAMRWorkflow_input_inputs_json_Input
  workflow: String
}

input mutationInput_KickoffAMRWorkflow_input_inputs_json_Input {
  start_from_mngs: Boolean
}

input mutationInput_KickoffWGSWorkflow_input_Input @example(value: "{\\"inputs_json\\":{\\"accession_id\\":\\"KX882832.1\\",\\"accession_name\\":\\"Hubei mosquito virus 2 strain mosZJ35453 segment 1 hypothetical protein 1 and hypothetical protein 2 genes, complete cds\\",\\"taxon_id\\":\\"1922926\\",\\"taxon_name\\":\\"Menispermaceae\\",\\"alignment_config_name\\":\\"config_name\\",\\"technology\\":\\"Illumina\\"},\\"workflow\\":\\"amr\\",\\"authenticityToken\\":\\"token\\"}") {
  authenticityToken: String
  inputs_json: mutationInput_KickoffWGSWorkflow_input_inputs_json_Input
  workflow: String
}

input mutationInput_KickoffWGSWorkflow_input_inputs_json_Input {
  accession_id: String
  accession_name: String
  alignment_config_name: String
  taxon_id: String
  taxon_name: String
  technology: String
}

input mutationInput_UpdateMetadata_input_Input {
  authenticityToken: String!
  field: String!
  value: mutationInput_UpdateMetadata_input_value_Input!
}

input mutationInput_UpdateMetadata_input_value_Input @oneOf {
  String: String
  query_SampleMetadata_metadata_items_location_validated_value_oneOf_1_Input: query_SampleMetadata_metadata_items_location_validated_value_oneOf_1_Input
}

input mutationInput_UpdateSampleNotes_input_Input {
  authenticityToken: String!
  value: String!
}

type mutation_KickoffWGSWorkflow_items {
  deprecated: Boolean
  executed_at: String
  id: String
  input_error: JSON
  inputs: mutation_KickoffWGSWorkflow_items_inputs
  parsed_cached_results: mutation_KickoffWGSWorkflow_items_parsed_cached_results
  run_finalized: Boolean
  status: String
  wdl_version: String
  workflow: String
}

type mutation_KickoffWGSWorkflow_items_inputs {
  accession_id: JSON
  accession_name: JSON
  card_version: String
  taxon_id: JSON
  taxon_name: JSON
  technology: String
  wildcard_version: String
}

type mutation_KickoffWGSWorkflow_items_parsed_cached_results {
  quality_metrics: mutation_KickoffWGSWorkflow_items_parsed_cached_results_quality_metrics
}

type mutation_KickoffWGSWorkflow_items_parsed_cached_results_quality_metrics {
  adjusted_remaining_reads: Int
  compression_ratio: Float
  fraction_subsampled: Float
  insert_size_mean: JSON
  insert_size_standard_deviation: JSON
  percent_remaining: Float
  qc_percent: Float
  total_ercc_reads: Int
  total_reads: Int
}

enum orderBy {
  asc
  asc_nulls_first
  asc_nulls_last
  desc
  desc_nulls_first
  desc_nulls_last
}

input queryInput_BulkDownloadCGOverview_input_Input {
  authenticityToken: String!
  downloadType: String!
  includeMetadata: Boolean!
  workflow: String!
  workflowRunIds: [Int]
  workflowRunIdsStrings: [String]
}

input queryInput_MetadataFields_input_Input {
  authenticityToken: String!
  sampleIds: [String]!
}

input queryInput_SampleMetadata_input_Input @example(value: "{\\"pipelineVersion\\":\\"8.0\\"}") {
  pipelineVersion: String
}

input queryInput_ValidateUserCanDeleteObjects_input_Input @example(value: "{\\"selectedIds\\":[28114,28151],\\"selectedIdsStrings\\":[\\"28114\\",\\"28151\\"],\\"workflow\\":\\"short-read-mngs\\",\\"authenticityToken\\":\\"token\\"}") {
  authenticityToken: String
  selectedIds: [Int]
  selectedIdsStrings: [String]
  workflow: String
}

input queryInput_fedBulkDownloads_input_Input @example(value: "{\\"searchBy\\":\\"string to search\\",\\"limit\\":10}") {
  limit: Int
  searchBy: String
}

input queryInput_fedConsensusGenomes_input_Input {
  limit: Int
  offset: Int
  orderBy: [queryInput_fedConsensusGenomes_input_orderBy_items_Input]
  todoRemove: queryInput_fedConsensusGenomes_input_todoRemove_Input
  where: queryInput_fedConsensusGenomes_input_where_Input
}

input queryInput_fedConsensusGenomes_input_orderBy_items_Input {
  accession: queryInput_fedConsensusGenomes_input_orderBy_items_accession_Input
  metrics: queryInput_fedConsensusGenomes_input_orderBy_items_metrics_Input
}

input queryInput_fedConsensusGenomes_input_orderBy_items_accession_Input {
  accessionId: String
}

input queryInput_fedConsensusGenomes_input_orderBy_items_metrics_Input {
  coverageDepth: String
  gcPercent: String
  nActg: String
  nAmbiguous: String
  nMissing: String
  percentGenomeCalled: String
  percentIdentity: String
  refSnps: String
  referenceGenomeLength: String
  totalReads: String
}

input queryInput_fedConsensusGenomes_input_todoRemove_Input {
  domain: String
  host: [Int]
  locationV2: [String]
  orderBy: String
  orderDir: String
  projectId: String
  sampleIds: [Int]
  search: String
  taxaLevels: [String]
  taxons: [Int]
  time: [String]
  tissue: [String]
  visibility: String
  workflow: String
  workflowRunIds: [Int]
}

input queryInput_fedConsensusGenomes_input_where_Input {
  collectionId: queryInput_fedConsensusGenomes_input_where_collectionId_Input
  producingRunId: queryInput_fedConsensusGenomes_input_where_producingRunId_Input
}

input queryInput_fedConsensusGenomes_input_where_collectionId_Input {
  _in: [Int]
}

input queryInput_fedConsensusGenomes_input_where_producingRunId_Input {
  _eq: String
  _in: [String]
}

input queryInput_fedSamples_input_Input {
  orderBy: queryInput_fedSamples_input_orderBy_Input
  sequencingReadsInput: queryInput_fedSamples_input_sequencingReadsInput_Input
  todoRemove: queryInput_fedSamples_input_todoRemove_Input
  where: queryInput_fedSamples_input_where_Input
}

input queryInput_fedSamples_input_orderBy_Input {
  dir: String
  key: String
}

input queryInput_fedSamples_input_sequencingReadsInput_Input {
  where: queryInput_fedSamples_input_sequencingReadsInput_where_Input
}

input queryInput_fedSamples_input_sequencingReadsInput_where_Input {
  consensusGenomes: queryInput_fedSamples_input_sequencingReadsInput_where_consensusGenomes_Input
  taxon: queryInput_fedSamples_input_sequencingReadsInput_where_taxon_Input
}

input queryInput_fedSamples_input_sequencingReadsInput_where_consensusGenomes_Input {
  taxon: queryInput_fedSamples_input_sequencingReadsInput_where_consensusGenomes_taxon_Input
}

input queryInput_fedSamples_input_sequencingReadsInput_where_consensusGenomes_taxon_Input {
  name: queryInput_fedSamples_input_sequencingReadsInput_where_consensusGenomes_taxon_name_Input
}

input queryInput_fedSamples_input_sequencingReadsInput_where_consensusGenomes_taxon_name_Input {
  _in: [String]
}

input queryInput_fedSamples_input_sequencingReadsInput_where_taxon_Input {
  name: queryInput_fedSamples_input_sequencingReadsInput_where_taxon_name_Input
}

input queryInput_fedSamples_input_sequencingReadsInput_where_taxon_name_Input {
  _in: [String]
}

input queryInput_fedSamples_input_todoRemove_Input {
  domain: String
  limit: Int
  listAllIds: Boolean
  offset: Int
  projectId: String
  taxaLevels: [String]
  taxons: [Int]
  time: [String]
  visibility: String
  workflow: String
}

input queryInput_fedSamples_input_where_Input {
  collectionLocation: queryInput_fedSamples_input_where_collectionLocation_Input
  hostOrganism: queryInput_fedSamples_input_where_hostOrganism_Input
  id: queryInput_fedSamples_input_where_id_Input
  name: queryInput_fedSamples_input_where_name_Input
  sampleType: queryInput_fedSamples_input_where_sampleType_Input
  sequencingReads: queryInput_fedSamples_input_where_sequencingReads_Input
}

input queryInput_fedSamples_input_where_collectionLocation_Input {
  _in: [String]
}

input queryInput_fedSamples_input_where_hostOrganism_Input {
  name: queryInput_fedSamples_input_where_hostOrganism_name_Input
}

input queryInput_fedSamples_input_where_hostOrganism_name_Input {
  _in: [String]
}

input queryInput_fedSamples_input_where_id_Input {
  _in: [String]
}

input queryInput_fedSamples_input_where_name_Input {
  _like: String
}

input queryInput_fedSamples_input_where_sampleType_Input {
  _in: [String]
}

input queryInput_fedSamples_input_where_sequencingReads_Input {
  consensusGenomes: queryInput_fedSamples_input_where_sequencingReads_consensusGenomes_Input
  taxon: queryInput_fedSamples_input_where_sequencingReads_taxon_Input
}

input queryInput_fedSamples_input_where_sequencingReads_consensusGenomes_Input {
  taxon: queryInput_fedSamples_input_where_sequencingReads_consensusGenomes_taxon_Input
}

input queryInput_fedSamples_input_where_sequencingReads_consensusGenomes_taxon_Input {
  name: queryInput_fedSamples_input_where_sequencingReads_consensusGenomes_taxon_name_Input
}

input queryInput_fedSamples_input_where_sequencingReads_consensusGenomes_taxon_name_Input {
  _in: [String]
}

input queryInput_fedSamples_input_where_sequencingReads_taxon_Input {
  name: queryInput_fedSamples_input_where_sequencingReads_taxon_name_Input
}

input queryInput_fedSamples_input_where_sequencingReads_taxon_name_Input {
  _in: [String]
}

input queryInput_fedSequencingReads_input_Input {
  consensusGenomesInput: queryInput_fedSequencingReads_input_consensusGenomesInput_Input
  limit: Int
  limitOffset: queryInput_fedSequencingReads_input_limitOffset_Input
  offset: Int
  orderBy: queryInput_fedSequencingReads_input_orderBy_Input
  orderByArray: [queryInput_fedSequencingReads_input_orderByArray_items_Input]
  todoRemove: queryInput_fedSequencingReads_input_todoRemove_Input
  where: queryInput_fedSequencingReads_input_where_Input
}

input queryInput_fedSequencingReads_input_consensusGenomesInput_Input {
  where: queryInput_fedSequencingReads_input_consensusGenomesInput_where_Input
}

input queryInput_fedSequencingReads_input_consensusGenomesInput_where_Input {
  producingRunId: queryInput_fedSequencingReads_input_consensusGenomesInput_where_producingRunId_Input
}

input queryInput_fedSequencingReads_input_consensusGenomesInput_where_producingRunId_Input {
  _in: [String]
}

input queryInput_fedSequencingReads_input_limitOffset_Input {
  limit: Int
  offset: Int
}

input queryInput_fedSequencingReads_input_orderByArray_items_Input {
  medakaModel: String
  nucleicAcid: String
  protocol: String
  sample: queryInput_fedSequencingReads_input_orderByArray_items_sample_Input
  technology: String
}

input queryInput_fedSequencingReads_input_orderByArray_items_sample_Input {
  collectionLocation: String
  hostOrganism: queryInput_fedSequencingReads_input_orderByArray_items_sample_hostOrganism_Input
  metadata: queryInput_fedSequencingReads_input_orderByArray_items_sample_metadata_Input
  name: String
  notes: String
  sampleType: String
  waterControl: String
}

input queryInput_fedSequencingReads_input_orderByArray_items_sample_hostOrganism_Input {
  name: String
}

input queryInput_fedSequencingReads_input_orderByArray_items_sample_metadata_Input {
  dir: String
  fieldName: String
}

input queryInput_fedSequencingReads_input_orderBy_Input {
  medakaModel: String
  nucleicAcid: String
  protocol: String
  sample: queryInput_fedSequencingReads_input_orderBy_sample_Input
  technology: String
}

input queryInput_fedSequencingReads_input_orderBy_sample_Input {
  collectionLocation: String
  hostOrganism: queryInput_fedSequencingReads_input_orderBy_sample_hostOrganism_Input
  metadata: queryInput_fedSequencingReads_input_orderBy_sample_metadata_Input
  name: String
  notes: String
  sampleType: String
  waterControl: String
}

input queryInput_fedSequencingReads_input_orderBy_sample_hostOrganism_Input {
  name: String
}

input queryInput_fedSequencingReads_input_orderBy_sample_metadata_Input {
  dir: String
  fieldName: String
}

input queryInput_fedSequencingReads_input_todoRemove_Input {
  domain: String
  host: [Int]
  locationV2: [String]
  orderBy: String
  orderDir: String
  projectId: String
  search: String
  taxaLevels: [String]
  taxons: [Int]
  time: [String]
  tissue: [String]
  visibility: String
  workflow: String
}

input queryInput_fedSequencingReads_input_where_Input {
  collectionId: queryInput_fedSequencingReads_input_where_collectionId_Input
  consensusGenomes: queryInput_fedSequencingReads_input_where_consensusGenomes_Input
  id: queryInput_fedSequencingReads_input_where_id_Input
  sample: queryInput_fedSequencingReads_input_where_sample_Input
  taxon: queryInput_fedSequencingReads_input_where_taxon_Input
}

input queryInput_fedSequencingReads_input_where_collectionId_Input {
  _in: [Int]
}

input queryInput_fedSequencingReads_input_where_consensusGenomes_Input {
  taxon: queryInput_fedSequencingReads_input_where_consensusGenomes_taxon_Input
}

input queryInput_fedSequencingReads_input_where_consensusGenomes_taxon_Input {
  name: queryInput_fedSequencingReads_input_where_consensusGenomes_taxon_name_Input
}

input queryInput_fedSequencingReads_input_where_consensusGenomes_taxon_name_Input {
  _in: [String]
}

input queryInput_fedSequencingReads_input_where_id_Input {
  _in: [String]
}

input queryInput_fedSequencingReads_input_where_sample_Input {
  collectionLocation: queryInput_fedSequencingReads_input_where_sample_collectionLocation_Input
  hostOrganism: queryInput_fedSequencingReads_input_where_sample_hostOrganism_Input
  name: queryInput_fedSequencingReads_input_where_sample_name_Input
  sampleType: queryInput_fedSequencingReads_input_where_sample_sampleType_Input
}

input queryInput_fedSequencingReads_input_where_sample_collectionLocation_Input {
  _in: [String]
}

input queryInput_fedSequencingReads_input_where_sample_hostOrganism_Input {
  name: queryInput_fedSequencingReads_input_where_sample_hostOrganism_name_Input
}

input queryInput_fedSequencingReads_input_where_sample_hostOrganism_name_Input {
  _in: [String]
}

input queryInput_fedSequencingReads_input_where_sample_name_Input {
  _iregex: String
}

input queryInput_fedSequencingReads_input_where_sample_sampleType_Input {
  _in: [String]
}

input queryInput_fedSequencingReads_input_where_taxon_Input {
  name: queryInput_fedSequencingReads_input_where_taxon_name_Input
}

input queryInput_fedSequencingReads_input_where_taxon_name_Input {
  _in: [String]
}

input queryInput_fedWorkflowRunsAggregateTotalCount_input_Input {
  todoRemove: queryInput_fedWorkflowRunsAggregateTotalCount_input_todoRemove_Input
  where: queryInput_fedWorkflowRunsAggregateTotalCount_input_where_Input
}

input queryInput_fedWorkflowRunsAggregateTotalCount_input_todoRemove_Input {
  domain: String
  projectId: String
}

input queryInput_fedWorkflowRunsAggregateTotalCount_input_where_Input {
  collectionId: queryInput_fedWorkflowRunsAggregateTotalCount_input_where_collectionId_Input
  workflowVersion: queryInput_fedWorkflowRunsAggregateTotalCount_input_where_workflowVersion_Input
}

input queryInput_fedWorkflowRunsAggregateTotalCount_input_where_collectionId_Input {
  _in: [Int]
}

input queryInput_fedWorkflowRunsAggregateTotalCount_input_where_workflowVersion_Input {
  workflow: queryInput_fedWorkflowRunsAggregateTotalCount_input_where_workflowVersion_workflow_Input
}

input queryInput_fedWorkflowRunsAggregateTotalCount_input_where_workflowVersion_workflow_Input {
  name: queryInput_fedWorkflowRunsAggregateTotalCount_input_where_workflowVersion_workflow_name_Input
}

input queryInput_fedWorkflowRunsAggregateTotalCount_input_where_workflowVersion_workflow_name_Input {
  _in: [String]
}

input queryInput_fedWorkflowRunsAggregate_input_Input {
  todoRemove: queryInput_fedWorkflowRunsAggregate_input_todoRemove_Input
  where: queryInput_fedWorkflowRunsAggregate_input_where_Input
}

input queryInput_fedWorkflowRunsAggregate_input_todoRemove_Input {
  annotations: [queryInput_fedWorkflowRunsAggregate_input_todoRemove_annotations_items_Input]
  domain: String
  host: [Int]
  locationV2: [String]
  projectId: String
  search: String
  taxaLevels: [String]
  taxon: [Int]
  taxonThresholds: [queryInput_fedWorkflowRunsAggregate_input_todoRemove_taxonThresholds_items_Input]
  time: [String]
  tissue: [String]
  visibility: String
}

input queryInput_fedWorkflowRunsAggregate_input_todoRemove_annotations_items_Input {
  name: String
}

input queryInput_fedWorkflowRunsAggregate_input_todoRemove_taxonThresholds_items_Input {
  count_type: String
  metric: String
  operator: String
  value: String
}

input queryInput_fedWorkflowRunsAggregate_input_where_Input {
  collectionId: queryInput_fedWorkflowRunsAggregate_input_where_collectionId_Input
  id: queryInput_fedWorkflowRunsAggregate_input_where_id_Input
  workflowVersion: queryInput_fedWorkflowRunsAggregate_input_where_workflowVersion_Input
}

input queryInput_fedWorkflowRunsAggregate_input_where_collectionId_Input {
  _in: [Int]
}

input queryInput_fedWorkflowRunsAggregate_input_where_id_Input {
  _in: [String]
}

input queryInput_fedWorkflowRunsAggregate_input_where_workflowVersion_Input {
  workflow: queryInput_fedWorkflowRunsAggregate_input_where_workflowVersion_workflow_Input
}

input queryInput_fedWorkflowRunsAggregate_input_where_workflowVersion_workflow_Input {
  name: queryInput_fedWorkflowRunsAggregate_input_where_workflowVersion_workflow_name_Input
}

input queryInput_fedWorkflowRunsAggregate_input_where_workflowVersion_workflow_name_Input {
  _in: [String]
}

input queryInput_fedWorkflowRuns_input_Input {
  entityInputsInput: queryInput_fedWorkflowRuns_input_entityInputsInput_Input
  orderBy: queryInput_fedWorkflowRuns_input_orderBy_Input
  orderByArray: [queryInput_fedWorkflowRuns_input_orderByArray_items_Input]
  todoRemove: queryInput_fedWorkflowRuns_input_todoRemove_Input
  where: queryInput_fedWorkflowRuns_input_where_Input
}

input queryInput_fedWorkflowRuns_input_entityInputsInput_Input {
  where: queryInput_fedWorkflowRuns_input_entityInputsInput_where_Input
}

input queryInput_fedWorkflowRuns_input_entityInputsInput_where_Input {
  fieldName: queryInput_fedWorkflowRuns_input_entityInputsInput_where_fieldName_Input
}

input queryInput_fedWorkflowRuns_input_entityInputsInput_where_fieldName_Input {
  _eq: String
}

input queryInput_fedWorkflowRuns_input_orderByArray_items_Input {
  startedAt: String
  workflowVersion: queryInput_fedWorkflowRuns_input_orderByArray_items_workflowVersion_Input
}

input queryInput_fedWorkflowRuns_input_orderByArray_items_workflowVersion_Input {
  version: String
}

input queryInput_fedWorkflowRuns_input_orderBy_Input {
  startedAt: String
}

input queryInput_fedWorkflowRuns_input_todoRemove_Input {
  authenticityToken: String
  domain: String
  host: [Int]
  locationV2: [String]
  orderBy: String
  orderDir: String
  projectId: String
  search: String
  taxon: [Int]
  taxonLevels: [String]
  time: [String]
  tissue: [String]
  visibility: String
  workflow: String
}

input queryInput_fedWorkflowRuns_input_where_Input {
  collectionId: queryInput_fedWorkflowRuns_input_where_collectionId_Input
  deprecatedById: queryInput_fedWorkflowRuns_input_where_deprecatedById_Input
  entityInputs: queryInput_fedWorkflowRuns_input_where_entityInputs_Input
  id: queryInput_fedWorkflowRuns_input_where_id_Input
  ownerUserId: queryInput_fedWorkflowRuns_input_where_ownerUserId_Input
  startedAt: queryInput_fedWorkflowRuns_input_where_startedAt_Input
  workflowVersion: queryInput_fedWorkflowRuns_input_where_workflowVersion_Input
}

input queryInput_fedWorkflowRuns_input_where_collectionId_Input {
  _in: [Int]
}

input queryInput_fedWorkflowRuns_input_where_deprecatedById_Input {
  _is_null: Boolean
}

input queryInput_fedWorkflowRuns_input_where_entityInputs_Input {
  entityType: queryInput_fedWorkflowRuns_input_where_entityInputs_entityType_Input
  inputEntityId: queryInput_fedWorkflowRuns_input_where_entityInputs_inputEntityId_Input
}

input queryInput_fedWorkflowRuns_input_where_entityInputs_entityType_Input {
  _eq: String
}

input queryInput_fedWorkflowRuns_input_where_entityInputs_inputEntityId_Input {
  _is_null: Boolean
}

input queryInput_fedWorkflowRuns_input_where_id_Input {
  _in: [String]
}

input queryInput_fedWorkflowRuns_input_where_ownerUserId_Input {
  _eq: Int
}

input queryInput_fedWorkflowRuns_input_where_startedAt_Input {
  _gte: String
}

input queryInput_fedWorkflowRuns_input_where_workflowVersion_Input {
  workflow: queryInput_fedWorkflowRuns_input_where_workflowVersion_workflow_Input
}

input queryInput_fedWorkflowRuns_input_where_workflowVersion_workflow_Input {
  name: queryInput_fedWorkflowRuns_input_where_workflowVersion_workflow_name_Input
}

input queryInput_fedWorkflowRuns_input_where_workflowVersion_workflow_name_Input {
  _in: [String]
}

type query_AmrWorkflowResults_amr_hit_items {
  aro_accession: String
  contig_coverage_breadth: String
  contig_percent_id: String
  contig_species: String
  contigs: String
  cutoff: String
  dpm: Float
  drug_class: String
  gene: String
  gene_family: String
  gene_id: String
  high_level_drug_class: String
  mechanism: String
  model: String
  read_coverage_breadth: String
  read_coverage_depth: String
  read_species: String
  reads: String
  rpm: Float
}

type query_AmrWorkflowResults_metric_amr {
  adjusted_remaining_reads: Int
  compression_ratio: Float
  fraction_subsampled: Float
  insert_size_mean: Int
  insert_size_standard_deviation: Float
  percent_remaining: Float
  qc_percent: Float
  total_ercc_reads: Int
  total_reads: Int
}

type query_Background_other_backgrounds_items {
  created_at: String
  description: String
  id: Int
  mass_normalized: Boolean
  name: String
  public_access: Int
  ready: Int
  updated_at: String
  user_id: Int
}

type query_ConsensusGenomeWorkflowResults_metric_consensus_genome {
  coverage_viz: query_ConsensusGenomeWorkflowResults_metric_consensus_genome_coverage_viz
  ercc_mapped_reads: Int
  gc_percent: Float
  mapped_reads: Int
  n_actg: Int
  n_ambiguous: Int
  n_missing: Int
  percent_genome_called: Float
  percent_identity: Float
  ref_snps: Int
  reference_genome_length: Int
  total_reads: Int
}

type query_ConsensusGenomeWorkflowResults_metric_consensus_genome_coverage_viz {
  coverage: [[Float]]
  coverage_bin_size: Float
  coverage_breadth: Float
  coverage_depth: Float
  max_aligned_length: Int
  total_length: Int
}

type query_ConsensusGenomeWorkflowResults_reference_genome {
  accession_id: String
  accession_name: String
  taxon: query_ConsensusGenomeWorkflowResults_reference_genome_taxon
}

type query_ConsensusGenomeWorkflowResults_reference_genome_taxon {
  id: String
  name: String
}

type query_CoverageVizSummary_items {
  coverage_breadth: JSON
  coverage_depth: JSON
  id: Int
  name: String
  num_contigs: Int
  num_reads: Int
  pipeline_id: Int
  score: Int
}

type query_MetadataFields_items {
  dataType: String
  default_for_new_host_genome: Int
  description: String
  examples: query_MetadataFields_items_examples
  group: String
  host_genome_ids: [Int]
  isBoolean: Boolean
  is_required: Int
  key: String
  name: String
  options: JSON
}

type query_MetadataFields_items_examples {
  all: [String]
}

type query_MngsWorkflowResults_fed_lineage_items {
  name: String
  rank: String
  tax_id: String
}

type query_MngsWorkflowResults_metric_mngs {
  adjusted_remaining_reads: Int
  assembled: Int
  fed_has_byteranges: Boolean
  num_reads: Int
  num_reads_after_subsampling: Int
  total_ercc_reads: Int
}

type query_MngsWorkflowResults_taxon_hit_results {
  taxon_hits: [query_MngsWorkflowResults_taxon_hit_results_taxon_hits_items]
}

type query_MngsWorkflowResults_taxon_hit_results_taxon_hits_items {
  alignment_length: Float
  base_count: Int
  bpm: Float
  count: Int
  count_type: String
  e_value: Float
  fed_agg_score: Float
  fed_bg_mean: Float
  fed_bg_mean_mass_normalized: Float
  fed_bg_stdev: Float
  fed_bg_stdev_mass_normalized: Float
  fed_max_z_score: Float
  fed_z_score: Float
  percent_identity: Int
  rpm: Float
  tax_id: Int
}

type query_Pathogens_items {
  tax_id: JSON
}

type query_PipelineData_edges_items {
  files: [query_PipelineData_edges_items_files_items]
  from: query_PipelineData_edges_items_from
  isIntraStage: Boolean
  to: query_PipelineData_edges_items_to
}

type query_PipelineData_edges_items_files_items {
  displayName: String
  url: JSON
}

type query_PipelineData_edges_items_from {
  stageIndex: Int
  stepIndex: Int
}

type query_PipelineData_edges_items_to {
  stageIndex: Int
  stepIndex: Int
}

type query_PipelineData_stages_items {
  jobStatus: String
  name: String
  steps: [query_PipelineData_stages_items_steps_items]
}

type query_PipelineData_stages_items_steps_items {
  description: String
  endTime: JSON
  inputEdges: [Int]
  inputVariables: [query_PipelineData_stages_items_steps_items_inputVariables_items]
  name: String
  outputEdges: [Int]
  outputFiles: [query_PipelineData_stages_items_steps_items_outputFiles_items]
  resources: [JSON]
  startTime: JSON
  status: String
}

type query_PipelineData_stages_items_steps_items_inputVariables_items {
  name: String
  type: String
}

type query_PipelineData_stages_items_steps_items_outputFiles_items {
  displayName: String
  url: JSON
}

type query_SampleForReport_pipeline_runs_items {
  adjusted_remaining_reads: Int
  alignment_config_name: String
  assembled: Int
  created_at: String
  id: String
  pipeline_version: String
  run_finalized: Boolean
  total_ercc_reads: Int
  wdl_version: String
}

type query_SampleForReport_project {
  id: String
  name: String
}

type query_SampleForReport_workflow_runs_items {
  deprecated: Boolean
  executed_at: String
  id: String
  input_error: String
  inputs: query_SampleForReport_workflow_runs_items_inputs
  run_finalized: Boolean
  status: String
  wdl_version: String
  workflow: String
}

type query_SampleForReport_workflow_runs_items_inputs {
  accession_id: String
  accession_name: String
  creation_source: String
  ref_fasta: String
  taxon_id: String
  taxon_name: String
  technology: String
}

type query_SampleMetadata_additional_info {
  editable: Boolean
  ercc_comparison: [query_SampleMetadata_additional_info_ercc_comparison_items]
  host_genome_name: String
  host_genome_taxa_category: String
  name: String
  notes: String
  pipeline_run: query_SampleMetadata_additional_info_pipeline_run
  project_id: Int
  project_name: String
  summary_stats: query_SampleMetadata_additional_info_summary_stats
  upload_date: String
}

type query_SampleMetadata_additional_info_ercc_comparison_items {
  actual: Int
  expected: JSON
  name: String
}

type query_SampleMetadata_additional_info_pipeline_run {
  adjusted_remaining_reads: Int
  alert_sent: Int
  alignment_config_id: Int
  assembled: Int
  compression_ratio: Float
  created_at: String
  dag_vars: JSON
  deleted_at: JSON
  deprecated: Boolean
  error_message: JSON
  executed_at: String
  finalized: Int
  fraction_subsampled: Float
  fraction_subsampled_bases: JSON
  guppy_basecaller_setting: JSON
  host_subtracted: String
  id: String
  job_status: String
  known_user_error: JSON
  mapped_reads: JSON
  max_input_fragments: Int
  pipeline_branch: String
  pipeline_commit: String
  pipeline_execution_strategy: String
  pipeline_version: String
  qc_percent: Float
  results_finalized: Int
  s3_output_prefix: String
  sample_id: Int
  sfn_execution_arn: String
  subsample: Int
  technology: String
  time_to_finalized: Int
  time_to_results_finalized: Int
  total_bases: JSON
  total_ercc_reads: Int
  total_reads: Int
  truncated: JSON
  truncated_bases: JSON
  unmapped_bases: JSON
  unmapped_reads: Int
  updated_at: String
  use_taxon_whitelist: Boolean
  version: query_SampleMetadata_additional_info_pipeline_run_version
  wdl_version: String
}

type query_SampleMetadata_additional_info_pipeline_run_version {
  alignment_db: String
  pipeline: String
}

type query_SampleMetadata_additional_info_summary_stats {
  adjusted_remaining_reads: Int
  compression_ratio: Float
  insert_size_mean: JSON
  insert_size_standard_deviation: JSON
  last_processed_at: String
  percent_remaining: Float
  qc_percent: Float
  reads_after_bowtie2_ercc_filtered: JSON
  reads_after_bowtie2_host_filtered: Int
  reads_after_czid_dedup: Int
  reads_after_fastp: Int
  reads_after_hisat2_host_filtered: Int
  unmapped_reads: Int
}

type query_SampleMetadata_metadata_items {
  base_type: String
  created_at: String
  date_validated_value: String
  id: String
  key: String
  location_id: Int
  location_validated_value: query_SampleMetadata_metadata_items_location_validated_value
  metadata_field_id: Int
  number_validated_value: String
  raw_value: String
  sample_id: Int
  string_validated_value: String
  updated_at: String
}

union query_SampleMetadata_metadata_items_location_validated_value = query_SampleMetadata_metadata_items_location_validated_value_oneOf_0 | query_SampleMetadata_metadata_items_location_validated_value_oneOf_1

type query_SampleMetadata_metadata_items_location_validated_value_oneOf_0 {
  name: String
}

type query_SampleMetadata_metadata_items_location_validated_value_oneOf_1 {
  city_id: String
  city_name: String
  country_code: String
  country_id: Int
  country_name: String
  created_at: String
  description: String
  geo_level: String
  id: String
  key: String
  lat: JSON
  lng: JSON
  locationiq_id: JSON
  name: String
  osm_id: Int
  osm_type: String
  raw_value: String
  refetch_adjusted_location: Boolean
  state_id: Int
  state_name: String
  subdivision_id: Int
  subdivision_name: String
  title: String
  updated_at: String
}

input query_SampleMetadata_metadata_items_location_validated_value_oneOf_1_Input {
  city_id: String
  city_name: String
  country_code: String
  country_id: Int
  country_name: String
  created_at: String
  description: String
  geo_level: String
  id: String
  key: String
  lat: JSON
  lng: JSON
  locationiq_id: JSON
  name: String
  osm_id: Int
  osm_type: String
  raw_value: String
  refetch_adjusted_location: Boolean
  state_id: Int
  state_name: String
  subdivision_id: Int
  subdivision_name: String
  title: String
  updated_at: String
}

type query_TaxonDist_NR {
  mean: Float
  rpm_list: [Float]
  stdev: Float
  tax_level: Int
}

type query_TaxonDist_NT {
  mean: Float
  rpm_list: [Float]
  stdev: Float
  tax_level: Int
}

type query_TaxonDist_merged_NT_NR {
  mean: Float
  rpm_list: [Float]
  stdev: Float
  tax_level: Int
}

type query_Taxons_items {
  common_name: JSON
  fed_category: JSON
  is_phage: JSON
  level: JSON
  name: JSON
  tax_id: JSON
  tax_id_genus: JSON
}

type query_UserBlastAnnotations_items {
  annotation: JSON
  tax_id: JSON
}

type query_fedBulkDownloads_items {
  analysisCount: Int
  downloadType: String
  entityInputFileType: String
  entityInputs: [query_fedBulkDownloads_items_entityInputs_items]
  errorMessage: String
  fileFormat: String
  fileSize: Int
  id: String
  logUrl: String
  ownerUserId: String
  params: [query_fedBulkDownloads_items_params_items]
  startedAt: String
  status: String
  url: String
}

type query_fedBulkDownloads_items_entityInputs_items {
  id: String
  name: String
}

type query_fedBulkDownloads_items_params_items {
  displayName: String
  paramType: String!
  value: String!
}

type query_fedConsensusGenomes_items {
  accession: query_fedConsensusGenomes_items_accession
  metrics: query_fedConsensusGenomes_items_metrics
  producingRunId: String
  referenceGenome: query_fedConsensusGenomes_items_referenceGenome
  sequencingRead: query_fedConsensusGenomes_items_sequencingRead
  taxon: query_fedConsensusGenomes_items_taxon
}

type query_fedConsensusGenomes_items_accession {
  accessionId: String!
  accessionName: String!
}

type query_fedConsensusGenomes_items_metrics {
  coverageBinSize: Float
  coverageBreadth: Float
  coverageDepth: Float
  coverageTotalLength: Float
  coverageViz: [[Float]]
  gcPercent: Float
  mappedReads: Int
  nActg: Int
  nAmbiguous: Int
  nMissing: Int
  percentGenomeCalled: Float
  percentIdentity: Float
  refSnps: Int
  referenceGenomeLength: Float
  totalReads: Int
}

type query_fedConsensusGenomes_items_referenceGenome {
  file: query_fedConsensusGenomes_items_referenceGenome_file
}

type query_fedConsensusGenomes_items_referenceGenome_file {
  downloadLink: query_fedConsensusGenomes_items_referenceGenome_file_downloadLink
}

type query_fedConsensusGenomes_items_referenceGenome_file_downloadLink {
  url: String
}

type query_fedConsensusGenomes_items_sequencingRead {
  id: String!
  medakaModel: String
  nucleicAcid: String!
  protocol: String
  sample: query_fedConsensusGenomes_items_sequencingRead_sample
  taxon: query_fedConsensusGenomes_items_sequencingRead_taxon
  technology: String!
}

type query_fedConsensusGenomes_items_sequencingRead_sample {
  collection: query_fedConsensusGenomes_items_sequencingRead_sample_collection
  collectionLocation: String!
  hostOrganism: query_fedConsensusGenomes_items_sequencingRead_sample_hostOrganism
  metadatas: query_fedConsensusGenomes_items_sequencingRead_sample_metadatas!
  name: String!
  notes: String
  ownerUserId: Float
  ownerUserName: String
  railsSampleId: Int
  sampleType: String!
  uploadError: String
  waterControl: Boolean
}

type query_fedConsensusGenomes_items_sequencingRead_sample_collection {
  name: String
  public: Boolean
}

type query_fedConsensusGenomes_items_sequencingRead_sample_hostOrganism {
  name: String
}

type query_fedConsensusGenomes_items_sequencingRead_sample_metadatas {
  edges: [query_fedConsensusGenomes_items_sequencingRead_sample_metadatas_edges_items]!
}

type query_fedConsensusGenomes_items_sequencingRead_sample_metadatas_edges_items {
  node: query_fedConsensusGenomes_items_sequencingRead_sample_metadatas_edges_items_node!
}

type query_fedConsensusGenomes_items_sequencingRead_sample_metadatas_edges_items_node {
  fieldName: String!
  value: String!
}

type query_fedConsensusGenomes_items_sequencingRead_taxon {
  name: String!
}

type query_fedConsensusGenomes_items_taxon {
  commonName: String
  id: String
  name: String!
}

type query_fedSamples_items {
  id: String!
  railsSampleId: Int
}

type query_fedSequencingReads_items {
  consensusGenomes: query_fedSequencingReads_items_consensusGenomes!
  id: String!
  medakaModel: String
  nucleicAcid: String!
  protocol: String
  sample: query_fedSequencingReads_items_sample
  taxon: query_fedSequencingReads_items_taxon
  technology: String!
}

type query_fedSequencingReads_items_consensusGenomes {
  edges: [query_fedSequencingReads_items_consensusGenomes_edges_items]!
}

type query_fedSequencingReads_items_consensusGenomes_edges_items {
  node: query_fedSequencingReads_items_consensusGenomes_edges_items_node!
}

type query_fedSequencingReads_items_consensusGenomes_edges_items_node {
  accession: query_fedSequencingReads_items_consensusGenomes_edges_items_node_accession
  metrics: query_fedSequencingReads_items_consensusGenomes_edges_items_node_metrics
  producingRunId: String
  referenceGenome: query_fedSequencingReads_items_consensusGenomes_edges_items_node_referenceGenome
  taxon: query_fedSequencingReads_items_consensusGenomes_edges_items_node_taxon
}

type query_fedSequencingReads_items_consensusGenomes_edges_items_node_accession {
  accessionId: String!
  accessionName: String!
}

type query_fedSequencingReads_items_consensusGenomes_edges_items_node_metrics {
  coverageDepth: Float
  gcPercent: Float
  nActg: Int
  nAmbiguous: Int
  nMissing: Int
  percentGenomeCalled: Float
  percentIdentity: Float
  refSnps: Int
  referenceGenomeLength: Float
  totalReads: Int
}

type query_fedSequencingReads_items_consensusGenomes_edges_items_node_referenceGenome {
  accessionId: String
  accessionName: String
}

type query_fedSequencingReads_items_consensusGenomes_edges_items_node_taxon {
  name: String!
}

type query_fedSequencingReads_items_sample {
  collection: query_fedSequencingReads_items_sample_collection
  collectionLocation: String!
  hostOrganism: query_fedSequencingReads_items_sample_hostOrganism
  metadatas: query_fedSequencingReads_items_sample_metadatas!
  name: String!
  notes: String
  ownerUserId: Float
  ownerUserName: String
  railsSampleId: Int
  sampleType: String!
  uploadError: String
  waterControl: Boolean
}

type query_fedSequencingReads_items_sample_collection {
  name: String
  public: Boolean
}

type query_fedSequencingReads_items_sample_hostOrganism {
  name: String!
}

type query_fedSequencingReads_items_sample_metadatas {
  edges: [query_fedSequencingReads_items_sample_metadatas_edges_items]!
}

type query_fedSequencingReads_items_sample_metadatas_edges_items {
  node: query_fedSequencingReads_items_sample_metadatas_edges_items_node!
}

type query_fedSequencingReads_items_sample_metadatas_edges_items_node {
  fieldName: String!
  value: String!
}

type query_fedSequencingReads_items_taxon {
  name: String!
}

type query_fedWorkflowRunsAggregateTotalCount_aggregate_items {
  count: Int!
  groupBy: query_fedWorkflowRunsAggregateTotalCount_aggregate_items_groupBy!
}

type query_fedWorkflowRunsAggregateTotalCount_aggregate_items_groupBy {
  workflowVersion: query_fedWorkflowRunsAggregateTotalCount_aggregate_items_groupBy_workflowVersion!
}

type query_fedWorkflowRunsAggregateTotalCount_aggregate_items_groupBy_workflowVersion {
  workflow: query_fedWorkflowRunsAggregateTotalCount_aggregate_items_groupBy_workflowVersion_workflow!
}

type query_fedWorkflowRunsAggregateTotalCount_aggregate_items_groupBy_workflowVersion_workflow {
  name: String!
}

type query_fedWorkflowRunsAggregate_aggregate_items {
  count: Int!
  groupBy: query_fedWorkflowRunsAggregate_aggregate_items_groupBy!
}

type query_fedWorkflowRunsAggregate_aggregate_items_groupBy {
  collectionId: Int!
  workflowVersion: query_fedWorkflowRunsAggregate_aggregate_items_groupBy_workflowVersion!
}

type query_fedWorkflowRunsAggregate_aggregate_items_groupBy_workflowVersion {
  workflow: query_fedWorkflowRunsAggregate_aggregate_items_groupBy_workflowVersion_workflow!
}

type query_fedWorkflowRunsAggregate_aggregate_items_groupBy_workflowVersion_workflow {
  name: String!
}

type query_fedWorkflowRuns_items {
  entityInputs: query_fedWorkflowRuns_items_entityInputs!
  id: String!
  ownerUserId: Int!
  rawInputsJson: String
  startedAt: String
  status: String
  workflowVersion: query_fedWorkflowRuns_items_workflowVersion
}

type query_fedWorkflowRuns_items_entityInputs {
  edges: [query_fedWorkflowRuns_items_entityInputs_edges_items]!
}

type query_fedWorkflowRuns_items_entityInputs_edges_items {
  node: query_fedWorkflowRuns_items_entityInputs_edges_items_node!
}

type query_fedWorkflowRuns_items_entityInputs_edges_items_node {
  entityType: String
  inputEntityId: String
}

type query_fedWorkflowRuns_items_workflowVersion {
  version: String
  workflow: query_fedWorkflowRuns_items_workflowVersion_workflow
}

type query_fedWorkflowRuns_items_workflowVersion_workflow {
  name: String
}"
`;
